// Code generated by Prisma (prisma@1.22.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  accountActivationCode: (
    where?: AccountActivationCodeWhereInput
  ) => Promise<boolean>;
  language: (where?: LanguageWhereInput) => Promise<boolean>;
  passwordResetCode: (where?: PasswordResetCodeWhereInput) => Promise<boolean>;
  payload: (where?: PayloadWhereInput) => Promise<boolean>;
  rating: (where?: RatingWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  topic: (where?: TopicWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  video: (where?: VideoWhereInput) => Promise<boolean>;
  vote: (where?: VoteWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  accountActivationCode: (
    where: AccountActivationCodeWhereUniqueInput
  ) => AccountActivationCodePromise;
  accountActivationCodes: (
    args?: {
      where?: AccountActivationCodeWhereInput;
      orderBy?: AccountActivationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AccountActivationCode>;
  accountActivationCodesConnection: (
    args?: {
      where?: AccountActivationCodeWhereInput;
      orderBy?: AccountActivationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AccountActivationCodeConnectionPromise;
  language: (where: LanguageWhereUniqueInput) => LanguagePromise;
  languages: (
    args?: {
      where?: LanguageWhereInput;
      orderBy?: LanguageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Language>;
  languagesConnection: (
    args?: {
      where?: LanguageWhereInput;
      orderBy?: LanguageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LanguageConnectionPromise;
  passwordResetCode: (
    where: PasswordResetCodeWhereUniqueInput
  ) => PasswordResetCodePromise;
  passwordResetCodes: (
    args?: {
      where?: PasswordResetCodeWhereInput;
      orderBy?: PasswordResetCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PasswordResetCode>;
  passwordResetCodesConnection: (
    args?: {
      where?: PasswordResetCodeWhereInput;
      orderBy?: PasswordResetCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PasswordResetCodeConnectionPromise;
  payloads: (
    args?: {
      where?: PayloadWhereInput;
      orderBy?: PayloadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Payload>;
  payloadsConnection: (
    args?: {
      where?: PayloadWhereInput;
      orderBy?: PayloadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PayloadConnectionPromise;
  ratings: (
    args?: {
      where?: RatingWhereInput;
      orderBy?: RatingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Rating>;
  ratingsConnection: (
    args?: {
      where?: RatingWhereInput;
      orderBy?: RatingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RatingConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tag>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnectionPromise;
  topic: (where: TopicWhereUniqueInput) => TopicPromise;
  topics: (
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Topic>;
  topicsConnection: (
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TopicConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  video: (where: VideoWhereUniqueInput) => VideoPromise;
  videos: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Video>;
  videosConnection: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VideoConnectionPromise;
  vote: (where: VoteWhereUniqueInput) => VotePromise;
  votes: (
    args?: {
      where?: VoteWhereInput;
      orderBy?: VoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Vote>;
  votesConnection: (
    args?: {
      where?: VoteWhereInput;
      orderBy?: VoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VoteConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccountActivationCode: (
    data: AccountActivationCodeCreateInput
  ) => AccountActivationCodePromise;
  updateAccountActivationCode: (
    args: {
      data: AccountActivationCodeUpdateInput;
      where: AccountActivationCodeWhereUniqueInput;
    }
  ) => AccountActivationCodePromise;
  upsertAccountActivationCode: (
    args: {
      where: AccountActivationCodeWhereUniqueInput;
      create: AccountActivationCodeCreateInput;
      update: AccountActivationCodeUpdateInput;
    }
  ) => AccountActivationCodePromise;
  deleteAccountActivationCode: (
    where: AccountActivationCodeWhereUniqueInput
  ) => AccountActivationCodePromise;
  deleteManyAccountActivationCodes: (
    where?: AccountActivationCodeWhereInput
  ) => BatchPayloadPromise;
  createLanguage: (data: LanguageCreateInput) => LanguagePromise;
  updateLanguage: (
    args: { data: LanguageUpdateInput; where: LanguageWhereUniqueInput }
  ) => LanguagePromise;
  updateManyLanguages: (
    args: { data: LanguageUpdateManyMutationInput; where?: LanguageWhereInput }
  ) => BatchPayloadPromise;
  upsertLanguage: (
    args: {
      where: LanguageWhereUniqueInput;
      create: LanguageCreateInput;
      update: LanguageUpdateInput;
    }
  ) => LanguagePromise;
  deleteLanguage: (where: LanguageWhereUniqueInput) => LanguagePromise;
  deleteManyLanguages: (where?: LanguageWhereInput) => BatchPayloadPromise;
  createPasswordResetCode: (
    data: PasswordResetCodeCreateInput
  ) => PasswordResetCodePromise;
  updatePasswordResetCode: (
    args: {
      data: PasswordResetCodeUpdateInput;
      where: PasswordResetCodeWhereUniqueInput;
    }
  ) => PasswordResetCodePromise;
  upsertPasswordResetCode: (
    args: {
      where: PasswordResetCodeWhereUniqueInput;
      create: PasswordResetCodeCreateInput;
      update: PasswordResetCodeUpdateInput;
    }
  ) => PasswordResetCodePromise;
  deletePasswordResetCode: (
    where: PasswordResetCodeWhereUniqueInput
  ) => PasswordResetCodePromise;
  deleteManyPasswordResetCodes: (
    where?: PasswordResetCodeWhereInput
  ) => BatchPayloadPromise;
  createPayload: (data: PayloadCreateInput) => PayloadPromise;
  updateManyPayloads: (
    args: { data: PayloadUpdateManyMutationInput; where?: PayloadWhereInput }
  ) => BatchPayloadPromise;
  deleteManyPayloads: (where?: PayloadWhereInput) => BatchPayloadPromise;
  createRating: (data: RatingCreateInput) => RatingPromise;
  updateManyRatings: (
    args: { data: RatingUpdateManyMutationInput; where?: RatingWhereInput }
  ) => BatchPayloadPromise;
  deleteManyRatings: (where?: RatingWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => TagPromise;
  updateManyTags: (
    args: { data: TagUpdateManyMutationInput; where?: TagWhereInput }
  ) => BatchPayloadPromise;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createTopic: (data: TopicCreateInput) => TopicPromise;
  updateTopic: (
    args: { data: TopicUpdateInput; where: TopicWhereUniqueInput }
  ) => TopicPromise;
  updateManyTopics: (
    args: { data: TopicUpdateManyMutationInput; where?: TopicWhereInput }
  ) => BatchPayloadPromise;
  upsertTopic: (
    args: {
      where: TopicWhereUniqueInput;
      create: TopicCreateInput;
      update: TopicUpdateInput;
    }
  ) => TopicPromise;
  deleteTopic: (where: TopicWhereUniqueInput) => TopicPromise;
  deleteManyTopics: (where?: TopicWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVideo: (data: VideoCreateInput) => VideoPromise;
  updateVideo: (
    args: { data: VideoUpdateInput; where: VideoWhereUniqueInput }
  ) => VideoPromise;
  updateManyVideos: (
    args: { data: VideoUpdateManyMutationInput; where?: VideoWhereInput }
  ) => BatchPayloadPromise;
  upsertVideo: (
    args: {
      where: VideoWhereUniqueInput;
      create: VideoCreateInput;
      update: VideoUpdateInput;
    }
  ) => VideoPromise;
  deleteVideo: (where: VideoWhereUniqueInput) => VideoPromise;
  deleteManyVideos: (where?: VideoWhereInput) => BatchPayloadPromise;
  createVote: (data: VoteCreateInput) => VotePromise;
  updateVote: (
    args: { data: VoteUpdateInput; where: VoteWhereUniqueInput }
  ) => VotePromise;
  updateManyVotes: (
    args: { data: VoteUpdateManyMutationInput; where?: VoteWhereInput }
  ) => BatchPayloadPromise;
  upsertVote: (
    args: {
      where: VoteWhereUniqueInput;
      create: VoteCreateInput;
      update: VoteUpdateInput;
    }
  ) => VotePromise;
  deleteVote: (where: VoteWhereUniqueInput) => VotePromise;
  deleteManyVotes: (where?: VoteWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  accountActivationCode: (
    where?: AccountActivationCodeSubscriptionWhereInput
  ) => AccountActivationCodeSubscriptionPayloadSubscription;
  language: (
    where?: LanguageSubscriptionWhereInput
  ) => LanguageSubscriptionPayloadSubscription;
  passwordResetCode: (
    where?: PasswordResetCodeSubscriptionWhereInput
  ) => PasswordResetCodeSubscriptionPayloadSubscription;
  payload: (
    where?: PayloadSubscriptionWhereInput
  ) => PayloadSubscriptionPayloadSubscription;
  rating: (
    where?: RatingSubscriptionWhereInput
  ) => RatingSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  topic: (
    where?: TopicSubscriptionWhereInput
  ) => TopicSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  video: (
    where?: VideoSubscriptionWhereInput
  ) => VideoSubscriptionPayloadSubscription;
  vote: (
    where?: VoteSubscriptionWhereInput
  ) => VoteSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AccountActivationCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VoteType = "UP" | "DOWN";

export type VoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RatingOrderByInput =
  | "votes_ASC"
  | "votes_DESC"
  | "total_ASC"
  | "total_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Complexity = "ELEMENTARY" | "BASIC" | "ADVANCED" | "EXPERT";

export type PasswordResetCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VideoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "ytId_ASC"
  | "ytId_DESC"
  | "complexity_ASC"
  | "complexity_DESC"
  | "voteScore_ASC"
  | "voteScore_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TopicOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isActivated_ASC"
  | "isActivated_DESC"
  | "login_ASC"
  | "login_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "role_ASC"
  | "role_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LanguageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PayloadOrderByInput =
  | "message_ASC"
  | "message_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type Role = "USER" | "EDITOR" | "ADMIN";

export interface TagUpdateWithWhereUniqueWithoutParentInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutParentDataInput;
}

export type AccountActivationCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithoutVideosBookmarkedDataInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  role?: Role;
  rank?: Int;
  videosAdded?: VideoUpdateManyWithoutAdderInput;
  votes?: VoteUpdateManyWithoutUserInput;
}

export interface PasswordResetCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  AND?: PasswordResetCodeWhereInput[] | PasswordResetCodeWhereInput;
  OR?: PasswordResetCodeWhereInput[] | PasswordResetCodeWhereInput;
  NOT?: PasswordResetCodeWhereInput[] | PasswordResetCodeWhereInput;
}

export interface AccountActivationCodeUpdateOneWithoutUserInput {
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AccountActivationCodeWhereUniqueInput;
}

export interface AccountActivationCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  AND?: AccountActivationCodeWhereInput[] | AccountActivationCodeWhereInput;
  OR?: AccountActivationCodeWhereInput[] | AccountActivationCodeWhereInput;
  NOT?: AccountActivationCodeWhereInput[] | AccountActivationCodeWhereInput;
}

export interface VoteCreateManyWithoutParentInput {
  create?: VoteCreateWithoutParentInput[] | VoteCreateWithoutParentInput;
  connect?: VoteWhereUniqueInput[] | VoteWhereUniqueInput;
}

export interface UserCreateWithoutPasswordResetCodeInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  role?: Role;
  rank?: Int;
  videosAdded?: VideoCreateManyWithoutAdderInput;
  videosBookmarked?: VideoCreateManyWithoutBookmarkersInput;
  votes?: VoteCreateManyWithoutUserInput;
}

export interface VoteCreateWithoutParentInput {
  user: UserCreateOneWithoutVotesInput;
  type: VoteType;
}

export interface VoteUpdateManyWithoutUserInput {
  create?: VoteCreateWithoutUserInput[] | VoteCreateWithoutUserInput;
  delete?: VoteWhereUniqueInput[] | VoteWhereUniqueInput;
  connect?: VoteWhereUniqueInput[] | VoteWhereUniqueInput;
  disconnect?: VoteWhereUniqueInput[] | VoteWhereUniqueInput;
  update?:
    | VoteUpdateWithWhereUniqueWithoutUserInput[]
    | VoteUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | VoteUpsertWithWhereUniqueWithoutUserInput[]
    | VoteUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: VoteScalarWhereInput[] | VoteScalarWhereInput;
  updateMany?:
    | VoteUpdateManyWithWhereNestedInput[]
    | VoteUpdateManyWithWhereNestedInput;
}

export interface UserCreateOneWithoutVotesInput {
  create?: UserCreateWithoutVotesInput;
  connect?: UserWhereUniqueInput;
}

export interface VoteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VoteWhereInput;
  AND?: VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput;
  OR?: VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput;
  NOT?: VoteSubscriptionWhereInput[] | VoteSubscriptionWhereInput;
}

export interface UserCreateWithoutVotesInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  role?: Role;
  rank?: Int;
  videosAdded?: VideoCreateManyWithoutAdderInput;
  videosBookmarked?: VideoCreateManyWithoutBookmarkersInput;
}

export interface VideoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoWhereInput;
  AND?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  OR?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  NOT?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
}

export interface AccountActivationCodeUpdateInput {
  user?: UserUpdateOneWithoutActivationCodeInput;
}

export interface VideoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  ytId?: String;
  ytId_not?: String;
  ytId_in?: String[] | String;
  ytId_not_in?: String[] | String;
  ytId_lt?: String;
  ytId_lte?: String;
  ytId_gt?: String;
  ytId_gte?: String;
  ytId_contains?: String;
  ytId_not_contains?: String;
  ytId_starts_with?: String;
  ytId_not_starts_with?: String;
  ytId_ends_with?: String;
  ytId_not_ends_with?: String;
  complexity?: Complexity;
  complexity_not?: Complexity;
  complexity_in?: Complexity[] | Complexity;
  complexity_not_in?: Complexity[] | Complexity;
  language?: LanguageWhereInput;
  topics_every?: TopicWhereInput;
  topics_some?: TopicWhereInput;
  topics_none?: TopicWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  adder?: UserWhereInput;
  bookmarkers_every?: UserWhereInput;
  bookmarkers_some?: UserWhereInput;
  bookmarkers_none?: UserWhereInput;
  votes_every?: VoteWhereInput;
  votes_some?: VoteWhereInput;
  votes_none?: VoteWhereInput;
  voteScore?: Int;
  voteScore_not?: Int;
  voteScore_in?: Int[] | Int;
  voteScore_not_in?: Int[] | Int;
  voteScore_lt?: Int;
  voteScore_lte?: Int;
  voteScore_gt?: Int;
  voteScore_gte?: Int;
  AND?: VideoWhereInput[] | VideoWhereInput;
  OR?: VideoWhereInput[] | VideoWhereInput;
  NOT?: VideoWhereInput[] | VideoWhereInput;
}

export interface UserUpdateOneWithoutActivationCodeInput {
  create?: UserCreateWithoutActivationCodeInput;
  update?: UserUpdateWithoutActivationCodeDataInput;
  upsert?: UserUpsertWithoutActivationCodeInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface TopicSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TopicWhereInput;
  AND?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
  OR?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
  NOT?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
}

export interface UserUpdateWithoutActivationCodeDataInput {
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  role?: Role;
  rank?: Int;
  videosAdded?: VideoUpdateManyWithoutAdderInput;
  videosBookmarked?: VideoUpdateManyWithoutBookmarkersInput;
  votes?: VoteUpdateManyWithoutUserInput;
}

export interface RatingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RatingWhereInput;
  AND?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
  OR?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
  NOT?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
}

export interface PasswordResetCodeUpdateOneWithoutUserInput {
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PasswordResetCodeWhereUniqueInput;
}

export interface PasswordResetCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PasswordResetCodeWhereInput;
  AND?:
    | PasswordResetCodeSubscriptionWhereInput[]
    | PasswordResetCodeSubscriptionWhereInput;
  OR?:
    | PasswordResetCodeSubscriptionWhereInput[]
    | PasswordResetCodeSubscriptionWhereInput;
  NOT?:
    | PasswordResetCodeSubscriptionWhereInput[]
    | PasswordResetCodeSubscriptionWhereInput;
}

export interface VideoUpdateManyWithoutAdderInput {
  create?: VideoCreateWithoutAdderInput[] | VideoCreateWithoutAdderInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutAdderInput[]
    | VideoUpdateWithWhereUniqueWithoutAdderInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutAdderInput[]
    | VideoUpsertWithWhereUniqueWithoutAdderInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface LanguageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LanguageWhereInput;
  AND?: LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput;
  OR?: LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput;
  NOT?: LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput;
}

export interface VideoUpdateWithWhereUniqueWithoutAdderInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutAdderDataInput;
}

export interface VoteUpdateManyMutationInput {
  type?: VoteType;
}

export interface VideoUpdateWithoutAdderDataInput {
  ytId?: String;
  complexity?: Complexity;
  language?: LanguageUpdateOneRequiredWithoutParentInput;
  topics?: TopicUpdateManyWithoutParentInput;
  tags?: TagUpdateManyWithoutParentInput;
  bookmarkers?: UserUpdateManyWithoutVideosBookmarkedInput;
  votes?: VoteUpdateManyWithoutParentInput;
  voteScore?: Int;
}

export type PasswordResetCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LanguageUpdateOneRequiredWithoutParentInput {
  create?: LanguageCreateWithoutParentInput;
  update?: LanguageUpdateWithoutParentDataInput;
  upsert?: LanguageUpsertWithoutParentInput;
  connect?: LanguageWhereUniqueInput;
}

export interface VideoUpdateManyMutationInput {
  ytId?: String;
  complexity?: Complexity;
  voteScore?: Int;
}

export interface LanguageUpdateWithoutParentDataInput {
  value?: String;
  text?: String;
}

export interface VideoCreateInput {
  ytId: String;
  complexity: Complexity;
  language: LanguageCreateOneWithoutParentInput;
  topics?: TopicCreateManyWithoutParentInput;
  tags?: TagCreateManyWithoutParentInput;
  adder: UserCreateOneWithoutVideosAddedInput;
  bookmarkers?: UserCreateManyWithoutVideosBookmarkedInput;
  votes?: VoteCreateManyWithoutParentInput;
  voteScore?: Int;
}

export interface LanguageUpsertWithoutParentInput {
  update: LanguageUpdateWithoutParentDataInput;
  create: LanguageCreateWithoutParentInput;
}

export interface UserUpdateManyMutationInput {
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  role?: Role;
  rank?: Int;
}

export interface TopicUpdateManyWithoutParentInput {
  create?: TopicCreateWithoutParentInput[] | TopicCreateWithoutParentInput;
  delete?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  connect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  disconnect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  update?:
    | TopicUpdateWithWhereUniqueWithoutParentInput[]
    | TopicUpdateWithWhereUniqueWithoutParentInput;
  upsert?:
    | TopicUpsertWithWhereUniqueWithoutParentInput[]
    | TopicUpsertWithWhereUniqueWithoutParentInput;
  deleteMany?: TopicScalarWhereInput[] | TopicScalarWhereInput;
  updateMany?:
    | TopicUpdateManyWithWhereNestedInput[]
    | TopicUpdateManyWithWhereNestedInput;
}

export interface UserCreateInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  role?: Role;
  rank?: Int;
  videosAdded?: VideoCreateManyWithoutAdderInput;
  videosBookmarked?: VideoCreateManyWithoutBookmarkersInput;
  votes?: VoteCreateManyWithoutUserInput;
}

export interface TopicUpdateWithWhereUniqueWithoutParentInput {
  where: TopicWhereUniqueInput;
  data: TopicUpdateWithoutParentDataInput;
}

export interface VideoUpsertWithWhereUniqueWithoutTopicsInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutTopicsDataInput;
  create: VideoCreateWithoutTopicsInput;
}

export interface TopicUpdateWithoutParentDataInput {
  value?: String;
  text?: String;
}

export interface VideoUpdateWithoutTopicsDataInput {
  ytId?: String;
  complexity?: Complexity;
  language?: LanguageUpdateOneRequiredWithoutParentInput;
  tags?: TagUpdateManyWithoutParentInput;
  adder?: UserUpdateOneRequiredWithoutVideosAddedInput;
  bookmarkers?: UserUpdateManyWithoutVideosBookmarkedInput;
  votes?: VoteUpdateManyWithoutParentInput;
  voteScore?: Int;
}

export interface TopicUpsertWithWhereUniqueWithoutParentInput {
  where: TopicWhereUniqueInput;
  update: TopicUpdateWithoutParentDataInput;
  create: TopicCreateWithoutParentInput;
}

export interface VideoUpdateManyWithoutTopicsInput {
  create?: VideoCreateWithoutTopicsInput[] | VideoCreateWithoutTopicsInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutTopicsInput[]
    | VideoUpdateWithWhereUniqueWithoutTopicsInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutTopicsInput[]
    | VideoUpsertWithWhereUniqueWithoutTopicsInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface TopicScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: TopicScalarWhereInput[] | TopicScalarWhereInput;
  OR?: TopicScalarWhereInput[] | TopicScalarWhereInput;
  NOT?: TopicScalarWhereInput[] | TopicScalarWhereInput;
}

export interface VideoCreateWithoutTopicsInput {
  ytId: String;
  complexity: Complexity;
  language: LanguageCreateOneWithoutParentInput;
  tags?: TagCreateManyWithoutParentInput;
  adder: UserCreateOneWithoutVideosAddedInput;
  bookmarkers?: UserCreateManyWithoutVideosBookmarkedInput;
  votes?: VoteCreateManyWithoutParentInput;
  voteScore?: Int;
}

export interface TopicUpdateManyWithWhereNestedInput {
  where: TopicScalarWhereInput;
  data: TopicUpdateManyDataInput;
}

export interface VideoCreateManyWithoutTopicsInput {
  create?: VideoCreateWithoutTopicsInput[] | VideoCreateWithoutTopicsInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface TopicUpdateManyDataInput {
  value?: String;
  text?: String;
}

export interface TagUpdateManyMutationInput {
  value?: String;
  text?: String;
}

export interface TagUpdateManyWithoutParentInput {
  create?: TagCreateWithoutParentInput[] | TagCreateWithoutParentInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  update?:
    | TagUpdateWithWhereUniqueWithoutParentInput[]
    | TagUpdateWithWhereUniqueWithoutParentInput;
  upsert?:
    | TagUpsertWithWhereUniqueWithoutParentInput[]
    | TagUpsertWithWhereUniqueWithoutParentInput;
  deleteMany?: TagScalarWhereInput[] | TagScalarWhereInput;
  updateMany?:
    | TagUpdateManyWithWhereNestedInput[]
    | TagUpdateManyWithWhereNestedInput;
}

export interface VideoUpsertWithWhereUniqueWithoutTagsInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutTagsDataInput;
  create: VideoCreateWithoutTagsInput;
}

export interface UserUpsertWithoutPasswordResetCodeInput {
  update: UserUpdateWithoutPasswordResetCodeDataInput;
  create: UserCreateWithoutPasswordResetCodeInput;
}

export interface VideoUpdateWithWhereUniqueWithoutTagsInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutTagsDataInput;
}

export interface TagUpdateWithoutParentDataInput {
  value?: String;
  text?: String;
}

export interface VideoUpdateManyWithoutTagsInput {
  create?: VideoCreateWithoutTagsInput[] | VideoCreateWithoutTagsInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutTagsInput[]
    | VideoUpdateWithWhereUniqueWithoutTagsInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutTagsInput[]
    | VideoUpsertWithWhereUniqueWithoutTagsInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface TagUpsertWithWhereUniqueWithoutParentInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutParentDataInput;
  create: TagCreateWithoutParentInput;
}

export interface VideoCreateWithoutTagsInput {
  ytId: String;
  complexity: Complexity;
  language: LanguageCreateOneWithoutParentInput;
  topics?: TopicCreateManyWithoutParentInput;
  adder: UserCreateOneWithoutVideosAddedInput;
  bookmarkers?: UserCreateManyWithoutVideosBookmarkedInput;
  votes?: VoteCreateManyWithoutParentInput;
  voteScore?: Int;
}

export interface TagScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: TagScalarWhereInput[] | TagScalarWhereInput;
  OR?: TagScalarWhereInput[] | TagScalarWhereInput;
  NOT?: TagScalarWhereInput[] | TagScalarWhereInput;
}

export interface VideoCreateManyWithoutTagsInput {
  create?: VideoCreateWithoutTagsInput[] | VideoCreateWithoutTagsInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface RatingUpdateManyMutationInput {
  votes?: Int;
  total?: Int;
}

export interface TagUpdateManyDataInput {
  value?: String;
  text?: String;
}

export interface RatingCreateInput {
  votes: Int;
  total: Int;
}

export interface UserUpdateManyWithoutVideosBookmarkedInput {
  create?:
    | UserCreateWithoutVideosBookmarkedInput[]
    | UserCreateWithoutVideosBookmarkedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutVideosBookmarkedInput[]
    | UserUpdateWithWhereUniqueWithoutVideosBookmarkedInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutVideosBookmarkedInput[]
    | UserUpsertWithWhereUniqueWithoutVideosBookmarkedInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface PayloadCreateInput {
  message: String;
}

export interface UserUpdateWithWhereUniqueWithoutVideosBookmarkedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutVideosBookmarkedDataInput;
}

export interface AccountActivationCodeCreateInput {
  user?: UserCreateOneWithoutActivationCodeInput;
}

export interface VoteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  parent?: VideoWhereInput;
  user?: UserWhereInput;
  type?: VoteType;
  type_not?: VoteType;
  type_in?: VoteType[] | VoteType;
  type_not_in?: VoteType[] | VoteType;
  AND?: VoteWhereInput[] | VoteWhereInput;
  OR?: VoteWhereInput[] | VoteWhereInput;
  NOT?: VoteWhereInput[] | VoteWhereInput;
}

export interface UserCreateWithoutActivationCodeInput {
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  role?: Role;
  rank?: Int;
  videosAdded?: VideoCreateManyWithoutAdderInput;
  videosBookmarked?: VideoCreateManyWithoutBookmarkersInput;
  votes?: VoteCreateManyWithoutUserInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  activationCode?: AccountActivationCodeWhereInput;
  passwordResetCode?: PasswordResetCodeWhereInput;
  isActivated?: Boolean;
  isActivated_not?: Boolean;
  login?: String;
  login_not?: String;
  login_in?: String[] | String;
  login_not_in?: String[] | String;
  login_lt?: String;
  login_lte?: String;
  login_gt?: String;
  login_gte?: String;
  login_contains?: String;
  login_not_contains?: String;
  login_starts_with?: String;
  login_not_starts_with?: String;
  login_ends_with?: String;
  login_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  rank?: Int;
  rank_not?: Int;
  rank_in?: Int[] | Int;
  rank_not_in?: Int[] | Int;
  rank_lt?: Int;
  rank_lte?: Int;
  rank_gt?: Int;
  rank_gte?: Int;
  videosAdded_every?: VideoWhereInput;
  videosAdded_some?: VideoWhereInput;
  videosAdded_none?: VideoWhereInput;
  videosBookmarked_every?: VideoWhereInput;
  videosBookmarked_some?: VideoWhereInput;
  videosBookmarked_none?: VideoWhereInput;
  votes_every?: VoteWhereInput;
  votes_some?: VoteWhereInput;
  votes_none?: VoteWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface VideoCreateManyWithoutAdderInput {
  create?: VideoCreateWithoutAdderInput[] | VideoCreateWithoutAdderInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface UserUpdateWithoutPasswordResetCodeDataInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  role?: Role;
  rank?: Int;
  videosAdded?: VideoUpdateManyWithoutAdderInput;
  videosBookmarked?: VideoUpdateManyWithoutBookmarkersInput;
  votes?: VoteUpdateManyWithoutUserInput;
}

export interface LanguageCreateOneWithoutParentInput {
  create?: LanguageCreateWithoutParentInput;
  connect?: LanguageWhereUniqueInput;
}

export interface VoteUpdateWithWhereUniqueWithoutUserInput {
  where: VoteWhereUniqueInput;
  data: VoteUpdateWithoutUserDataInput;
}

export interface TopicCreateManyWithoutParentInput {
  create?: TopicCreateWithoutParentInput[] | TopicCreateWithoutParentInput;
  connect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
}

export interface VoteUpdateWithoutUserDataInput {
  parent?: VideoUpdateOneRequiredWithoutVotesInput;
  type?: VoteType;
}

export interface TagCreateManyWithoutParentInput {
  create?: TagCreateWithoutParentInput[] | TagCreateWithoutParentInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface VideoUpdateOneRequiredWithoutVotesInput {
  create?: VideoCreateWithoutVotesInput;
  update?: VideoUpdateWithoutVotesDataInput;
  upsert?: VideoUpsertWithoutVotesInput;
  connect?: VideoWhereUniqueInput;
}

export interface UserCreateManyWithoutVideosBookmarkedInput {
  create?:
    | UserCreateWithoutVideosBookmarkedInput[]
    | UserCreateWithoutVideosBookmarkedInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface VideoUpdateWithoutVotesDataInput {
  ytId?: String;
  complexity?: Complexity;
  language?: LanguageUpdateOneRequiredWithoutParentInput;
  topics?: TopicUpdateManyWithoutParentInput;
  tags?: TagUpdateManyWithoutParentInput;
  adder?: UserUpdateOneRequiredWithoutVideosAddedInput;
  bookmarkers?: UserUpdateManyWithoutVideosBookmarkedInput;
  voteScore?: Int;
}

export interface AccountActivationCodeCreateOneWithoutUserInput {
  connect?: AccountActivationCodeWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutVideosAddedInput {
  create?: UserCreateWithoutVideosAddedInput;
  update?: UserUpdateWithoutVideosAddedDataInput;
  upsert?: UserUpsertWithoutVideosAddedInput;
  connect?: UserWhereUniqueInput;
}

export interface VoteCreateWithoutUserInput {
  parent: VideoCreateOneWithoutVotesInput;
  type: VoteType;
}

export interface UserUpdateWithoutVideosAddedDataInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  role?: Role;
  rank?: Int;
  videosBookmarked?: VideoUpdateManyWithoutBookmarkersInput;
  votes?: VoteUpdateManyWithoutUserInput;
}

export interface VideoCreateWithoutVotesInput {
  ytId: String;
  complexity: Complexity;
  language: LanguageCreateOneWithoutParentInput;
  topics?: TopicCreateManyWithoutParentInput;
  tags?: TagCreateManyWithoutParentInput;
  adder: UserCreateOneWithoutVideosAddedInput;
  bookmarkers?: UserCreateManyWithoutVideosBookmarkedInput;
  voteScore?: Int;
}

export interface VideoUpdateManyWithoutBookmarkersInput {
  create?:
    | VideoCreateWithoutBookmarkersInput[]
    | VideoCreateWithoutBookmarkersInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutBookmarkersInput[]
    | VideoUpdateWithWhereUniqueWithoutBookmarkersInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutBookmarkersInput[]
    | VideoUpsertWithWhereUniqueWithoutBookmarkersInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface UserCreateWithoutVideosAddedInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  role?: Role;
  rank?: Int;
  videosBookmarked?: VideoCreateManyWithoutBookmarkersInput;
  votes?: VoteCreateManyWithoutUserInput;
}

export interface VideoUpdateWithWhereUniqueWithoutBookmarkersInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutBookmarkersDataInput;
}

export interface VideoCreateWithoutBookmarkersInput {
  ytId: String;
  complexity: Complexity;
  language: LanguageCreateOneWithoutParentInput;
  topics?: TopicCreateManyWithoutParentInput;
  tags?: TagCreateManyWithoutParentInput;
  adder: UserCreateOneWithoutVideosAddedInput;
  votes?: VoteCreateManyWithoutParentInput;
  voteScore?: Int;
}

export interface VideoUpdateWithoutBookmarkersDataInput {
  ytId?: String;
  complexity?: Complexity;
  language?: LanguageUpdateOneRequiredWithoutParentInput;
  topics?: TopicUpdateManyWithoutParentInput;
  tags?: TagUpdateManyWithoutParentInput;
  adder?: UserUpdateOneRequiredWithoutVideosAddedInput;
  votes?: VoteUpdateManyWithoutParentInput;
  voteScore?: Int;
}

export interface TopicWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  parent_every?: VideoWhereInput;
  parent_some?: VideoWhereInput;
  parent_none?: VideoWhereInput;
  AND?: TopicWhereInput[] | TopicWhereInput;
  OR?: TopicWhereInput[] | TopicWhereInput;
  NOT?: TopicWhereInput[] | TopicWhereInput;
}

export interface VoteUpdateManyWithoutParentInput {
  create?: VoteCreateWithoutParentInput[] | VoteCreateWithoutParentInput;
  delete?: VoteWhereUniqueInput[] | VoteWhereUniqueInput;
  connect?: VoteWhereUniqueInput[] | VoteWhereUniqueInput;
  disconnect?: VoteWhereUniqueInput[] | VoteWhereUniqueInput;
  update?:
    | VoteUpdateWithWhereUniqueWithoutParentInput[]
    | VoteUpdateWithWhereUniqueWithoutParentInput;
  upsert?:
    | VoteUpsertWithWhereUniqueWithoutParentInput[]
    | VoteUpsertWithWhereUniqueWithoutParentInput;
  deleteMany?: VoteScalarWhereInput[] | VoteScalarWhereInput;
  updateMany?:
    | VoteUpdateManyWithWhereNestedInput[]
    | VoteUpdateManyWithWhereNestedInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface VoteUpdateWithWhereUniqueWithoutParentInput {
  where: VoteWhereUniqueInput;
  data: VoteUpdateWithoutParentDataInput;
}

export interface PayloadSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PayloadWhereInput;
  AND?: PayloadSubscriptionWhereInput[] | PayloadSubscriptionWhereInput;
  OR?: PayloadSubscriptionWhereInput[] | PayloadSubscriptionWhereInput;
  NOT?: PayloadSubscriptionWhereInput[] | PayloadSubscriptionWhereInput;
}

export interface VoteUpdateWithoutParentDataInput {
  user?: UserUpdateOneRequiredWithoutVotesInput;
  type?: VoteType;
}

export interface AccountActivationCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AccountActivationCodeWhereInput;
  AND?:
    | AccountActivationCodeSubscriptionWhereInput[]
    | AccountActivationCodeSubscriptionWhereInput;
  OR?:
    | AccountActivationCodeSubscriptionWhereInput[]
    | AccountActivationCodeSubscriptionWhereInput;
  NOT?:
    | AccountActivationCodeSubscriptionWhereInput[]
    | AccountActivationCodeSubscriptionWhereInput;
}

export interface UserUpdateOneRequiredWithoutVotesInput {
  create?: UserCreateWithoutVotesInput;
  update?: UserUpdateWithoutVotesDataInput;
  upsert?: UserUpsertWithoutVotesInput;
  connect?: UserWhereUniqueInput;
}

export interface VoteCreateInput {
  parent: VideoCreateOneWithoutVotesInput;
  user: UserCreateOneWithoutVotesInput;
  type: VoteType;
}

export interface UserUpdateWithoutVotesDataInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  role?: Role;
  rank?: Int;
  videosAdded?: VideoUpdateManyWithoutAdderInput;
  videosBookmarked?: VideoUpdateManyWithoutBookmarkersInput;
}

export interface PayloadWhereInput {
  message?: String;
  message_not?: String;
  message_in?: String[] | String;
  message_not_in?: String[] | String;
  message_lt?: String;
  message_lte?: String;
  message_gt?: String;
  message_gte?: String;
  message_contains?: String;
  message_not_contains?: String;
  message_starts_with?: String;
  message_not_starts_with?: String;
  message_ends_with?: String;
  message_not_ends_with?: String;
  AND?: PayloadWhereInput[] | PayloadWhereInput;
  OR?: PayloadWhereInput[] | PayloadWhereInput;
  NOT?: PayloadWhereInput[] | PayloadWhereInput;
}

export interface UserUpsertWithoutVotesInput {
  update: UserUpdateWithoutVotesDataInput;
  create: UserCreateWithoutVotesInput;
}

export interface TopicUpdateManyMutationInput {
  value?: String;
  text?: String;
}

export interface VoteUpsertWithWhereUniqueWithoutParentInput {
  where: VoteWhereUniqueInput;
  update: VoteUpdateWithoutParentDataInput;
  create: VoteCreateWithoutParentInput;
}

export interface VideoUpdateWithWhereUniqueWithoutTopicsInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutTopicsDataInput;
}

export interface VoteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: VoteType;
  type_not?: VoteType;
  type_in?: VoteType[] | VoteType;
  type_not_in?: VoteType[] | VoteType;
  AND?: VoteScalarWhereInput[] | VoteScalarWhereInput;
  OR?: VoteScalarWhereInput[] | VoteScalarWhereInput;
  NOT?: VoteScalarWhereInput[] | VoteScalarWhereInput;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  value?: String;
  text?: String;
}>;

export interface VoteUpdateManyWithWhereNestedInput {
  where: VoteScalarWhereInput;
  data: VoteUpdateManyDataInput;
}

export type TopicWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  value?: String;
  text?: String;
}>;

export interface VoteUpdateManyDataInput {
  type?: VoteType;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  login?: String;
  email?: String;
}>;

export interface VideoUpsertWithWhereUniqueWithoutBookmarkersInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutBookmarkersDataInput;
  create: VideoCreateWithoutBookmarkersInput;
}

export type VideoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  ytId?: String;
}>;

export interface VideoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  ytId?: String;
  ytId_not?: String;
  ytId_in?: String[] | String;
  ytId_not_in?: String[] | String;
  ytId_lt?: String;
  ytId_lte?: String;
  ytId_gt?: String;
  ytId_gte?: String;
  ytId_contains?: String;
  ytId_not_contains?: String;
  ytId_starts_with?: String;
  ytId_not_starts_with?: String;
  ytId_ends_with?: String;
  ytId_not_ends_with?: String;
  complexity?: Complexity;
  complexity_not?: Complexity;
  complexity_in?: Complexity[] | Complexity;
  complexity_not_in?: Complexity[] | Complexity;
  voteScore?: Int;
  voteScore_not?: Int;
  voteScore_in?: Int[] | Int;
  voteScore_not_in?: Int[] | Int;
  voteScore_lt?: Int;
  voteScore_lte?: Int;
  voteScore_gt?: Int;
  voteScore_gte?: Int;
  AND?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  OR?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  NOT?: VideoScalarWhereInput[] | VideoScalarWhereInput;
}

export type VoteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VideoUpdateManyWithWhereNestedInput {
  where: VideoScalarWhereInput;
  data: VideoUpdateManyDataInput;
}

export interface PasswordResetCodeCreateOneWithoutUserInput {
  connect?: PasswordResetCodeWhereUniqueInput;
}

export interface VideoUpdateManyDataInput {
  ytId?: String;
  complexity?: Complexity;
  voteScore?: Int;
}

export interface LanguageCreateWithoutParentInput {
  value: String;
  text: String;
}

export interface UserUpsertWithoutVideosAddedInput {
  update: UserUpdateWithoutVideosAddedDataInput;
  create: UserCreateWithoutVideosAddedInput;
}

export interface TagCreateWithoutParentInput {
  value: String;
  text: String;
}

export interface VideoUpsertWithoutVotesInput {
  update: VideoUpdateWithoutVotesDataInput;
  create: VideoCreateWithoutVotesInput;
}

export interface VoteCreateManyWithoutUserInput {
  create?: VoteCreateWithoutUserInput[] | VoteCreateWithoutUserInput;
  connect?: VoteWhereUniqueInput[] | VoteWhereUniqueInput;
}

export interface VoteUpsertWithWhereUniqueWithoutUserInput {
  where: VoteWhereUniqueInput;
  update: VoteUpdateWithoutUserDataInput;
  create: VoteCreateWithoutUserInput;
}

export interface UserCreateOneWithoutVideosAddedInput {
  create?: UserCreateWithoutVideosAddedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertWithWhereUniqueWithoutVideosBookmarkedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutVideosBookmarkedDataInput;
  create: UserCreateWithoutVideosBookmarkedInput;
}

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  parent_every?: VideoWhereInput;
  parent_some?: VideoWhereInput;
  parent_none?: VideoWhereInput;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isActivated?: Boolean;
  isActivated_not?: Boolean;
  login?: String;
  login_not?: String;
  login_in?: String[] | String;
  login_not_in?: String[] | String;
  login_lt?: String;
  login_lte?: String;
  login_gt?: String;
  login_gte?: String;
  login_contains?: String;
  login_not_contains?: String;
  login_starts_with?: String;
  login_not_starts_with?: String;
  login_ends_with?: String;
  login_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  role?: Role;
  role_not?: Role;
  role_in?: Role[] | Role;
  role_not_in?: Role[] | Role;
  rank?: Int;
  rank_not?: Int;
  rank_in?: Int[] | Int;
  rank_not_in?: Int[] | Int;
  rank_lt?: Int;
  rank_lte?: Int;
  rank_gt?: Int;
  rank_gte?: Int;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface VoteUpdateInput {
  parent?: VideoUpdateOneRequiredWithoutVotesInput;
  user?: UserUpdateOneRequiredWithoutVotesInput;
  type?: VoteType;
}

export interface UserUpdateManyDataInput {
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  role?: Role;
  rank?: Int;
}

export interface UserUpdateInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  role?: Role;
  rank?: Int;
  videosAdded?: VideoUpdateManyWithoutAdderInput;
  videosBookmarked?: VideoUpdateManyWithoutBookmarkersInput;
  votes?: VoteUpdateManyWithoutUserInput;
}

export interface VideoUpsertWithWhereUniqueWithoutAdderInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutAdderDataInput;
  create: VideoCreateWithoutAdderInput;
}

export interface TopicUpdateInput {
  value?: String;
  text?: String;
  parent?: VideoUpdateManyWithoutTopicsInput;
}

export interface UserUpsertWithoutActivationCodeInput {
  update: UserUpdateWithoutActivationCodeDataInput;
  create: UserCreateWithoutActivationCodeInput;
}

export interface VideoUpdateWithoutTagsDataInput {
  ytId?: String;
  complexity?: Complexity;
  language?: LanguageUpdateOneRequiredWithoutParentInput;
  topics?: TopicUpdateManyWithoutParentInput;
  adder?: UserUpdateOneRequiredWithoutVideosAddedInput;
  bookmarkers?: UserUpdateManyWithoutVideosBookmarkedInput;
  votes?: VoteUpdateManyWithoutParentInput;
  voteScore?: Int;
}

export interface UserUpdateOneWithoutPasswordResetCodeInput {
  create?: UserCreateWithoutPasswordResetCodeInput;
  update?: UserUpdateWithoutPasswordResetCodeDataInput;
  upsert?: UserUpsertWithoutPasswordResetCodeInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface TagCreateInput {
  value: String;
  text: String;
  parent?: VideoCreateManyWithoutTagsInput;
}

export interface PasswordResetCodeUpdateInput {
  user?: UserUpdateOneWithoutPasswordResetCodeInput;
}

export interface UserCreateOneWithoutActivationCodeInput {
  create?: UserCreateWithoutActivationCodeInput;
  connect?: UserWhereUniqueInput;
}

export interface LanguageCreateInput {
  value: String;
  text: String;
  parent?: VideoCreateManyWithoutLanguageInput;
}

export interface TopicCreateWithoutParentInput {
  value: String;
  text: String;
}

export interface VideoCreateManyWithoutLanguageInput {
  create?: VideoCreateWithoutLanguageInput[] | VideoCreateWithoutLanguageInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoCreateOneWithoutVotesInput {
  create?: VideoCreateWithoutVotesInput;
  connect?: VideoWhereUniqueInput;
}

export interface VideoCreateWithoutLanguageInput {
  ytId: String;
  complexity: Complexity;
  topics?: TopicCreateManyWithoutParentInput;
  tags?: TagCreateManyWithoutParentInput;
  adder: UserCreateOneWithoutVideosAddedInput;
  bookmarkers?: UserCreateManyWithoutVideosBookmarkedInput;
  votes?: VoteCreateManyWithoutParentInput;
  voteScore?: Int;
}

export interface LanguageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  parent_every?: VideoWhereInput;
  parent_some?: VideoWhereInput;
  parent_none?: VideoWhereInput;
  AND?: LanguageWhereInput[] | LanguageWhereInput;
  OR?: LanguageWhereInput[] | LanguageWhereInput;
  NOT?: LanguageWhereInput[] | LanguageWhereInput;
}

export interface LanguageUpdateInput {
  value?: String;
  text?: String;
  parent?: VideoUpdateManyWithoutLanguageInput;
}

export interface VideoUpdateInput {
  ytId?: String;
  complexity?: Complexity;
  language?: LanguageUpdateOneRequiredWithoutParentInput;
  topics?: TopicUpdateManyWithoutParentInput;
  tags?: TagUpdateManyWithoutParentInput;
  adder?: UserUpdateOneRequiredWithoutVideosAddedInput;
  bookmarkers?: UserUpdateManyWithoutVideosBookmarkedInput;
  votes?: VoteUpdateManyWithoutParentInput;
  voteScore?: Int;
}

export interface VideoUpdateManyWithoutLanguageInput {
  create?: VideoCreateWithoutLanguageInput[] | VideoCreateWithoutLanguageInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutLanguageInput[]
    | VideoUpdateWithWhereUniqueWithoutLanguageInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutLanguageInput[]
    | VideoUpsertWithWhereUniqueWithoutLanguageInput;
  deleteMany?: VideoScalarWhereInput[] | VideoScalarWhereInput;
  updateMany?:
    | VideoUpdateManyWithWhereNestedInput[]
    | VideoUpdateManyWithWhereNestedInput;
}

export interface TopicCreateInput {
  value: String;
  text: String;
  parent?: VideoCreateManyWithoutTopicsInput;
}

export interface VideoUpdateWithWhereUniqueWithoutLanguageInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutLanguageDataInput;
}

export interface PayloadUpdateManyMutationInput {
  message?: String;
}

export interface VideoUpdateWithoutLanguageDataInput {
  ytId?: String;
  complexity?: Complexity;
  topics?: TopicUpdateManyWithoutParentInput;
  tags?: TagUpdateManyWithoutParentInput;
  adder?: UserUpdateOneRequiredWithoutVideosAddedInput;
  bookmarkers?: UserUpdateManyWithoutVideosBookmarkedInput;
  votes?: VoteUpdateManyWithoutParentInput;
  voteScore?: Int;
}

export interface UserCreateWithoutVideosBookmarkedInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  role?: Role;
  rank?: Int;
  videosAdded?: VideoCreateManyWithoutAdderInput;
  votes?: VoteCreateManyWithoutUserInput;
}

export interface UserCreateOneWithoutPasswordResetCodeInput {
  create?: UserCreateWithoutPasswordResetCodeInput;
  connect?: UserWhereUniqueInput;
}

export interface PasswordResetCodeCreateInput {
  user?: UserCreateOneWithoutPasswordResetCodeInput;
}

export interface LanguageUpdateManyMutationInput {
  value?: String;
  text?: String;
}

export interface VideoUpsertWithWhereUniqueWithoutLanguageInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutLanguageDataInput;
  create: VideoCreateWithoutLanguageInput;
}

export interface VideoCreateManyWithoutBookmarkersInput {
  create?:
    | VideoCreateWithoutBookmarkersInput[]
    | VideoCreateWithoutBookmarkersInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoCreateWithoutAdderInput {
  ytId: String;
  complexity: Complexity;
  language: LanguageCreateOneWithoutParentInput;
  topics?: TopicCreateManyWithoutParentInput;
  tags?: TagCreateManyWithoutParentInput;
  bookmarkers?: UserCreateManyWithoutVideosBookmarkedInput;
  votes?: VoteCreateManyWithoutParentInput;
  voteScore?: Int;
}

export interface TagUpdateInput {
  value?: String;
  text?: String;
  parent?: VideoUpdateManyWithoutTagsInput;
}

export interface RatingWhereInput {
  votes?: Int;
  votes_not?: Int;
  votes_in?: Int[] | Int;
  votes_not_in?: Int[] | Int;
  votes_lt?: Int;
  votes_lte?: Int;
  votes_gt?: Int;
  votes_gte?: Int;
  total?: Int;
  total_not?: Int;
  total_in?: Int[] | Int;
  total_not_in?: Int[] | Int;
  total_lt?: Int;
  total_lte?: Int;
  total_gt?: Int;
  total_gte?: Int;
  AND?: RatingWhereInput[] | RatingWhereInput;
  OR?: RatingWhereInput[] | RatingWhereInput;
  NOT?: RatingWhereInput[] | RatingWhereInput;
}

export type LanguageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  value?: String;
  text?: String;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface VotePreviousValues {
  id: ID_Output;
  type: VoteType;
}

export interface VotePreviousValuesPromise
  extends Promise<VotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<VoteType>;
}

export interface VotePreviousValuesSubscription
  extends Promise<AsyncIterator<VotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<VoteType>>;
}

export interface AggregateLanguage {
  count: Int;
}

export interface AggregateLanguagePromise
  extends Promise<AggregateLanguage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLanguageSubscription
  extends Promise<AsyncIterator<AggregateLanguage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Video {
  id: ID_Output;
  ytId: String;
  complexity: Complexity;
  voteScore: Int;
}

export interface VideoPromise extends Promise<Video>, Fragmentable {
  id: () => Promise<ID_Output>;
  ytId: () => Promise<String>;
  complexity: () => Promise<Complexity>;
  language: <T = LanguagePromise>() => T;
  topics: <T = FragmentableArray<Topic>>(
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  adder: <T = UserPromise>() => T;
  bookmarkers: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  votes: <T = FragmentableArray<Vote>>(
    args?: {
      where?: VoteWhereInput;
      orderBy?: VoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  voteScore: () => Promise<Int>;
}

export interface VideoSubscription
  extends Promise<AsyncIterator<Video>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ytId: () => Promise<AsyncIterator<String>>;
  complexity: () => Promise<AsyncIterator<Complexity>>;
  language: <T = LanguageSubscription>() => T;
  topics: <T = Promise<AsyncIterator<TopicSubscription>>>(
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  adder: <T = UserSubscription>() => T;
  bookmarkers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  votes: <T = Promise<AsyncIterator<VoteSubscription>>>(
    args?: {
      where?: VoteWhereInput;
      orderBy?: VoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  voteScore: () => Promise<AsyncIterator<Int>>;
}

export interface LanguageEdge {
  cursor: String;
}

export interface LanguageEdgePromise
  extends Promise<LanguageEdge>,
    Fragmentable {
  node: <T = LanguagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LanguageEdgeSubscription
  extends Promise<AsyncIterator<LanguageEdge>>,
    Fragmentable {
  node: <T = LanguageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Language {
  id: ID_Output;
  value: String;
  text: String;
}

export interface LanguagePromise extends Promise<Language>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  text: () => Promise<String>;
  parent: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LanguageSubscription
  extends Promise<AsyncIterator<Language>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  parent: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LanguageConnection {}

export interface LanguageConnectionPromise
  extends Promise<LanguageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LanguageEdge>>() => T;
  aggregate: <T = AggregateLanguagePromise>() => T;
}

export interface LanguageConnectionSubscription
  extends Promise<AsyncIterator<LanguageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LanguageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLanguageSubscription>() => T;
}

export interface AggregateVote {
  count: Int;
}

export interface AggregateVotePromise
  extends Promise<AggregateVote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVoteSubscription
  extends Promise<AsyncIterator<AggregateVote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AccountActivationCode {
  id: ID_Output;
}

export interface AccountActivationCodePromise
  extends Promise<AccountActivationCode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
}

export interface AccountActivationCodeSubscription
  extends Promise<AsyncIterator<AccountActivationCode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
}

export interface VoteConnection {}

export interface VoteConnectionPromise
  extends Promise<VoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VoteEdge>>() => T;
  aggregate: <T = AggregateVotePromise>() => T;
}

export interface VoteConnectionSubscription
  extends Promise<AsyncIterator<VoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVoteSubscription>() => T;
}

export interface AccountActivationCodeSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AccountActivationCodeSubscriptionPayloadPromise
  extends Promise<AccountActivationCodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccountActivationCodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccountActivationCodePreviousValuesPromise>() => T;
}

export interface AccountActivationCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccountActivationCodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccountActivationCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccountActivationCodePreviousValuesSubscription>() => T;
}

export interface VideoEdge {
  cursor: String;
}

export interface VideoEdgePromise extends Promise<VideoEdge>, Fragmentable {
  node: <T = VideoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoEdgeSubscription
  extends Promise<AsyncIterator<VideoEdge>>,
    Fragmentable {
  node: <T = VideoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AccountActivationCodePreviousValues {
  id: ID_Output;
}

export interface AccountActivationCodePreviousValuesPromise
  extends Promise<AccountActivationCodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface AccountActivationCodePreviousValuesSubscription
  extends Promise<AsyncIterator<AccountActivationCodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoConnection {}

export interface VideoConnectionPromise
  extends Promise<VideoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoEdge>>() => T;
  aggregate: <T = AggregateVideoPromise>() => T;
}

export interface VideoConnectionSubscription
  extends Promise<AsyncIterator<VideoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoSubscription>() => T;
}

export interface VideoSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface VideoSubscriptionPayloadPromise
  extends Promise<VideoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoPreviousValuesPromise>() => T;
}

export interface VideoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AggregateTopic {
  count: Int;
}

export interface AggregateTopicPromise
  extends Promise<AggregateTopic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopicSubscription
  extends Promise<AsyncIterator<AggregateTopic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TopicConnection {}

export interface TopicConnectionPromise
  extends Promise<TopicConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TopicEdge>>() => T;
  aggregate: <T = AggregateTopicPromise>() => T;
}

export interface TopicConnectionSubscription
  extends Promise<AsyncIterator<TopicConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TopicEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTopicSubscription>() => T;
}

export interface LanguageSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface LanguageSubscriptionPayloadPromise
  extends Promise<LanguageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LanguagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LanguagePreviousValuesPromise>() => T;
}

export interface LanguageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LanguageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LanguageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LanguagePreviousValuesSubscription>() => T;
}

export interface TagEdge {
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LanguagePreviousValues {
  id: ID_Output;
  value: String;
  text: String;
}

export interface LanguagePreviousValuesPromise
  extends Promise<LanguagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  text: () => Promise<String>;
}

export interface LanguagePreviousValuesSubscription
  extends Promise<AsyncIterator<LanguagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRating {
  count: Int;
}

export interface AggregateRatingPromise
  extends Promise<AggregateRating>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRatingSubscription
  extends Promise<AsyncIterator<AggregateRating>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateAccountActivationCode {
  count: Int;
}

export interface AggregateAccountActivationCodePromise
  extends Promise<AggregateAccountActivationCode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccountActivationCodeSubscription
  extends Promise<AsyncIterator<AggregateAccountActivationCode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RatingConnection {}

export interface RatingConnectionPromise
  extends Promise<RatingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RatingEdge>>() => T;
  aggregate: <T = AggregateRatingPromise>() => T;
}

export interface RatingConnectionSubscription
  extends Promise<AsyncIterator<RatingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RatingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRatingSubscription>() => T;
}

export interface PasswordResetCodeSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PasswordResetCodeSubscriptionPayloadPromise
  extends Promise<PasswordResetCodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PasswordResetCodePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PasswordResetCodePreviousValuesPromise>() => T;
}

export interface PasswordResetCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PasswordResetCodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PasswordResetCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PasswordResetCodePreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  role: Role;
  rank: Int;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  activationCode: <T = AccountActivationCodePromise>() => T;
  passwordResetCode: <T = PasswordResetCodePromise>() => T;
  isActivated: () => Promise<Boolean>;
  login: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  role: () => Promise<Role>;
  rank: () => Promise<Int>;
  videosAdded: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  videosBookmarked: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  votes: <T = FragmentableArray<Vote>>(
    args?: {
      where?: VoteWhereInput;
      orderBy?: VoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  activationCode: <T = AccountActivationCodeSubscription>() => T;
  passwordResetCode: <T = PasswordResetCodeSubscription>() => T;
  isActivated: () => Promise<AsyncIterator<Boolean>>;
  login: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  rank: () => Promise<AsyncIterator<Int>>;
  videosAdded: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  videosBookmarked: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  votes: <T = Promise<AsyncIterator<VoteSubscription>>>(
    args?: {
      where?: VoteWhereInput;
      orderBy?: VoteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PasswordResetCodePreviousValues {
  id: ID_Output;
}

export interface PasswordResetCodePreviousValuesPromise
  extends Promise<PasswordResetCodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface PasswordResetCodePreviousValuesSubscription
  extends Promise<AsyncIterator<PasswordResetCodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface PayloadEdge {
  cursor: String;
}

export interface PayloadEdgePromise extends Promise<PayloadEdge>, Fragmentable {
  node: <T = PayloadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PayloadEdgeSubscription
  extends Promise<AsyncIterator<PayloadEdge>>,
    Fragmentable {
  node: <T = PayloadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AccountActivationCodeEdge {
  cursor: String;
}

export interface AccountActivationCodeEdgePromise
  extends Promise<AccountActivationCodeEdge>,
    Fragmentable {
  node: <T = AccountActivationCodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AccountActivationCodeEdgeSubscription
  extends Promise<AsyncIterator<AccountActivationCodeEdge>>,
    Fragmentable {
  node: <T = AccountActivationCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Payload {
  message: String;
}

export interface PayloadPromise extends Promise<Payload>, Fragmentable {
  message: () => Promise<String>;
}

export interface PayloadSubscription
  extends Promise<AsyncIterator<Payload>>,
    Fragmentable {
  message: () => Promise<AsyncIterator<String>>;
}

export interface PayloadSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PayloadSubscriptionPayloadPromise
  extends Promise<PayloadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PayloadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PayloadPreviousValuesPromise>() => T;
}

export interface PayloadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PayloadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PayloadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PayloadPreviousValuesSubscription>() => T;
}

export interface AggregatePasswordResetCode {
  count: Int;
}

export interface AggregatePasswordResetCodePromise
  extends Promise<AggregatePasswordResetCode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePasswordResetCodeSubscription
  extends Promise<AsyncIterator<AggregatePasswordResetCode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PayloadPreviousValues {
  message: String;
}

export interface PayloadPreviousValuesPromise
  extends Promise<PayloadPreviousValues>,
    Fragmentable {
  message: () => Promise<String>;
}

export interface PayloadPreviousValuesSubscription
  extends Promise<AsyncIterator<PayloadPreviousValues>>,
    Fragmentable {
  message: () => Promise<AsyncIterator<String>>;
}

export interface PasswordResetCodeConnection {}

export interface PasswordResetCodeConnectionPromise
  extends Promise<PasswordResetCodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PasswordResetCodeEdge>>() => T;
  aggregate: <T = AggregatePasswordResetCodePromise>() => T;
}

export interface PasswordResetCodeConnectionSubscription
  extends Promise<AsyncIterator<PasswordResetCodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PasswordResetCodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePasswordResetCodeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface RatingSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RatingSubscriptionPayloadPromise
  extends Promise<RatingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RatingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RatingPreviousValuesPromise>() => T;
}

export interface RatingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RatingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RatingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RatingPreviousValuesSubscription>() => T;
}

export interface VoteEdge {
  cursor: String;
}

export interface VoteEdgePromise extends Promise<VoteEdge>, Fragmentable {
  node: <T = VotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VoteEdgeSubscription
  extends Promise<AsyncIterator<VoteEdge>>,
    Fragmentable {
  node: <T = VoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RatingPreviousValues {
  votes: Int;
  total: Int;
}

export interface RatingPreviousValuesPromise
  extends Promise<RatingPreviousValues>,
    Fragmentable {
  votes: () => Promise<Int>;
  total: () => Promise<Int>;
}

export interface RatingPreviousValuesSubscription
  extends Promise<AsyncIterator<RatingPreviousValues>>,
    Fragmentable {
  votes: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
}

export interface TopicEdge {
  cursor: String;
}

export interface TopicEdgePromise extends Promise<TopicEdge>, Fragmentable {
  node: <T = TopicPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TopicEdgeSubscription
  extends Promise<AsyncIterator<TopicEdge>>,
    Fragmentable {
  node: <T = TopicSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AccountActivationCodeConnection {}

export interface AccountActivationCodeConnectionPromise
  extends Promise<AccountActivationCodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AccountActivationCodeEdge>>() => T;
  aggregate: <T = AggregateAccountActivationCodePromise>() => T;
}

export interface AccountActivationCodeConnectionSubscription
  extends Promise<AsyncIterator<AccountActivationCodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<AccountActivationCodeEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateAccountActivationCodeSubscription>() => T;
}

export interface TagConnection {}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface Rating {
  votes: Int;
  total: Int;
}

export interface RatingPromise extends Promise<Rating>, Fragmentable {
  votes: () => Promise<Int>;
  total: () => Promise<Int>;
}

export interface RatingSubscription
  extends Promise<AsyncIterator<Rating>>,
    Fragmentable {
  votes: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
}

export interface TagPreviousValues {
  id: ID_Output;
  value: String;
  text: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  text: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface PayloadConnection {}

export interface PayloadConnectionPromise
  extends Promise<PayloadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PayloadEdge>>() => T;
  aggregate: <T = AggregatePayloadPromise>() => T;
}

export interface PayloadConnectionSubscription
  extends Promise<AsyncIterator<PayloadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PayloadEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePayloadSubscription>() => T;
}

export interface VideoPreviousValues {
  id: ID_Output;
  ytId: String;
  complexity: Complexity;
  voteScore: Int;
}

export interface VideoPreviousValuesPromise
  extends Promise<VideoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  ytId: () => Promise<String>;
  complexity: () => Promise<Complexity>;
  voteScore: () => Promise<Int>;
}

export interface VideoPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ytId: () => Promise<AsyncIterator<String>>;
  complexity: () => Promise<AsyncIterator<Complexity>>;
  voteScore: () => Promise<AsyncIterator<Int>>;
}

export interface PasswordResetCodeEdge {
  cursor: String;
}

export interface PasswordResetCodeEdgePromise
  extends Promise<PasswordResetCodeEdge>,
    Fragmentable {
  node: <T = PasswordResetCodePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PasswordResetCodeEdgeSubscription
  extends Promise<AsyncIterator<PasswordResetCodeEdge>>,
    Fragmentable {
  node: <T = PasswordResetCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TopicSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TopicSubscriptionPayloadPromise
  extends Promise<TopicSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TopicPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TopicPreviousValuesPromise>() => T;
}

export interface TopicSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopicSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopicSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TopicPreviousValuesSubscription>() => T;
}

export interface Topic {
  id: ID_Output;
  value: String;
  text: String;
}

export interface TopicPromise extends Promise<Topic>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  text: () => Promise<String>;
  parent: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TopicSubscription
  extends Promise<AsyncIterator<Topic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  parent: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TopicPreviousValues {
  id: ID_Output;
  value: String;
  text: String;
}

export interface TopicPreviousValuesPromise
  extends Promise<TopicPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  text: () => Promise<String>;
}

export interface TopicPreviousValuesSubscription
  extends Promise<AsyncIterator<TopicPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePayload {
  count: Int;
}

export interface AggregatePayloadPromise
  extends Promise<AggregatePayload>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePayloadSubscription
  extends Promise<AsyncIterator<AggregatePayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Tag {
  id: ID_Output;
  value: String;
  text: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  text: () => Promise<String>;
  parent: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  parent: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  role: Role;
  rank: Int;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isActivated: () => Promise<Boolean>;
  login: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  role: () => Promise<Role>;
  rank: () => Promise<Int>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isActivated: () => Promise<AsyncIterator<Boolean>>;
  login: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  rank: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Vote {
  id: ID_Output;
  type: VoteType;
}

export interface VotePromise extends Promise<Vote>, Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = VideoPromise>() => T;
  user: <T = UserPromise>() => T;
  type: () => Promise<VoteType>;
}

export interface VoteSubscription
  extends Promise<AsyncIterator<Vote>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: <T = VideoSubscription>() => T;
  user: <T = UserSubscription>() => T;
  type: () => Promise<AsyncIterator<VoteType>>;
}

export interface PasswordResetCode {
  id: ID_Output;
}

export interface PasswordResetCodePromise
  extends Promise<PasswordResetCode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
}

export interface PasswordResetCodeSubscription
  extends Promise<AsyncIterator<PasswordResetCode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
}

export interface RatingEdge {
  cursor: String;
}

export interface RatingEdgePromise extends Promise<RatingEdge>, Fragmentable {
  node: <T = RatingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RatingEdgeSubscription
  extends Promise<AsyncIterator<RatingEdge>>,
    Fragmentable {
  node: <T = RatingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideo {
  count: Int;
}

export interface AggregateVideoPromise
  extends Promise<AggregateVideo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoSubscription
  extends Promise<AsyncIterator<AggregateVideo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VoteSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface VoteSubscriptionPayloadPromise
  extends Promise<VoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VotePreviousValuesPromise>() => T;
}

export interface VoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VotePreviousValuesSubscription>() => T;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "AccountActivationCode",
    embedded: false
  },
  {
    name: "Complexity",
    embedded: false
  },
  {
    name: "Language",
    embedded: false
  },
  {
    name: "PasswordResetCode",
    embedded: false
  },
  {
    name: "Payload",
    embedded: false
  },
  {
    name: "Rating",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Topic",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Video",
    embedded: false
  },
  {
    name: "Vote",
    embedded: false
  },
  {
    name: "VoteType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
