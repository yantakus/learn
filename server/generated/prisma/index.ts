// Code generated by Prisma (prisma@1.20.0-beta.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  accountActivationCode: (
    where?: AccountActivationCodeWhereInput
  ) => Promise<boolean>;
  passwordResetCode: (where?: PasswordResetCodeWhereInput) => Promise<boolean>;
  payload: (where?: PayloadWhereInput) => Promise<boolean>;
  rating: (where?: RatingWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  topic: (where?: TopicWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  video: (where?: VideoWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  accountActivationCode: (
    where: AccountActivationCodeWhereUniqueInput
  ) => AccountActivationCode;
  accountActivationCodes: (
    args?: {
      where?: AccountActivationCodeWhereInput;
      orderBy?: AccountActivationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AccountActivationCode>;
  accountActivationCodesConnection: (
    args?: {
      where?: AccountActivationCodeWhereInput;
      orderBy?: AccountActivationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AccountActivationCodeConnection;
  passwordResetCode: (
    where: PasswordResetCodeWhereUniqueInput
  ) => PasswordResetCode;
  passwordResetCodes: (
    args?: {
      where?: PasswordResetCodeWhereInput;
      orderBy?: PasswordResetCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PasswordResetCode>;
  passwordResetCodesConnection: (
    args?: {
      where?: PasswordResetCodeWhereInput;
      orderBy?: PasswordResetCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PasswordResetCodeConnection;
  payloads: (
    args?: {
      where?: PayloadWhereInput;
      orderBy?: PayloadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Payload>;
  payloadsConnection: (
    args?: {
      where?: PayloadWhereInput;
      orderBy?: PayloadOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PayloadConnection;
  ratings: (
    args?: {
      where?: RatingWhereInput;
      orderBy?: RatingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Rating>;
  ratingsConnection: (
    args?: {
      where?: RatingWhereInput;
      orderBy?: RatingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RatingConnection;
  tag: (where: TagWhereUniqueInput) => Tag;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tag>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnection;
  topic: (where: TopicWhereUniqueInput) => Topic;
  topics: (
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Topic>;
  topicsConnection: (
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TopicConnection;
  user: (where: UserWhereUniqueInput) => User;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnection;
  video: (where: VideoWhereUniqueInput) => Video;
  videos: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Video>;
  videosConnection: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VideoConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccountActivationCode: (
    data: AccountActivationCodeCreateInput
  ) => AccountActivationCode;
  updateAccountActivationCode: (
    args: {
      data: AccountActivationCodeUpdateInput;
      where: AccountActivationCodeWhereUniqueInput;
    }
  ) => AccountActivationCode;
  updateManyAccountActivationCodes: (
    args: {
      data: AccountActivationCodeUpdateInput;
      where?: AccountActivationCodeWhereInput;
    }
  ) => BatchPayload;
  upsertAccountActivationCode: (
    args: {
      where: AccountActivationCodeWhereUniqueInput;
      create: AccountActivationCodeCreateInput;
      update: AccountActivationCodeUpdateInput;
    }
  ) => AccountActivationCode;
  deleteAccountActivationCode: (
    where: AccountActivationCodeWhereUniqueInput
  ) => AccountActivationCode;
  deleteManyAccountActivationCodes: (
    where?: AccountActivationCodeWhereInput
  ) => BatchPayload;
  createPasswordResetCode: (
    data: PasswordResetCodeCreateInput
  ) => PasswordResetCode;
  updatePasswordResetCode: (
    args: {
      data: PasswordResetCodeUpdateInput;
      where: PasswordResetCodeWhereUniqueInput;
    }
  ) => PasswordResetCode;
  updateManyPasswordResetCodes: (
    args: {
      data: PasswordResetCodeUpdateInput;
      where?: PasswordResetCodeWhereInput;
    }
  ) => BatchPayload;
  upsertPasswordResetCode: (
    args: {
      where: PasswordResetCodeWhereUniqueInput;
      create: PasswordResetCodeCreateInput;
      update: PasswordResetCodeUpdateInput;
    }
  ) => PasswordResetCode;
  deletePasswordResetCode: (
    where: PasswordResetCodeWhereUniqueInput
  ) => PasswordResetCode;
  deleteManyPasswordResetCodes: (
    where?: PasswordResetCodeWhereInput
  ) => BatchPayload;
  createPayload: (data: PayloadCreateInput) => Payload;
  updateManyPayloads: (
    args: { data: PayloadUpdateInput; where?: PayloadWhereInput }
  ) => BatchPayload;
  deleteManyPayloads: (where?: PayloadWhereInput) => BatchPayload;
  createRating: (data: RatingCreateInput) => Rating;
  updateManyRatings: (
    args: { data: RatingUpdateInput; where?: RatingWhereInput }
  ) => BatchPayload;
  deleteManyRatings: (where?: RatingWhereInput) => BatchPayload;
  createTag: (data: TagCreateInput) => Tag;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => Tag;
  updateManyTags: (
    args: { data: TagUpdateInput; where?: TagWhereInput }
  ) => BatchPayload;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => Tag;
  deleteTag: (where: TagWhereUniqueInput) => Tag;
  deleteManyTags: (where?: TagWhereInput) => BatchPayload;
  createTopic: (data: TopicCreateInput) => Topic;
  updateTopic: (
    args: { data: TopicUpdateInput; where: TopicWhereUniqueInput }
  ) => Topic;
  updateManyTopics: (
    args: { data: TopicUpdateInput; where?: TopicWhereInput }
  ) => BatchPayload;
  upsertTopic: (
    args: {
      where: TopicWhereUniqueInput;
      create: TopicCreateInput;
      update: TopicUpdateInput;
    }
  ) => Topic;
  deleteTopic: (where: TopicWhereUniqueInput) => Topic;
  deleteManyTopics: (where?: TopicWhereInput) => BatchPayload;
  createUser: (data: UserCreateInput) => User;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => User;
  updateManyUsers: (
    args: { data: UserUpdateInput; where?: UserWhereInput }
  ) => BatchPayload;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => User;
  deleteUser: (where: UserWhereUniqueInput) => User;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayload;
  createVideo: (data: VideoCreateInput) => Video;
  updateVideo: (
    args: { data: VideoUpdateInput; where: VideoWhereUniqueInput }
  ) => Video;
  updateManyVideos: (
    args: { data: VideoUpdateInput; where?: VideoWhereInput }
  ) => BatchPayload;
  upsertVideo: (
    args: {
      where: VideoWhereUniqueInput;
      create: VideoCreateInput;
      update: VideoUpdateInput;
    }
  ) => Video;
  deleteVideo: (where: VideoWhereUniqueInput) => Video;
  deleteManyVideos: (where?: VideoWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  accountActivationCode: (
    where?: AccountActivationCodeSubscriptionWhereInput
  ) => AccountActivationCodeSubscriptionPayloadSubscription;
  passwordResetCode: (
    where?: PasswordResetCodeSubscriptionWhereInput
  ) => PasswordResetCodeSubscriptionPayloadSubscription;
  payload: (
    where?: PayloadSubscriptionWhereInput
  ) => PayloadSubscriptionPayloadSubscription;
  rating: (
    where?: RatingSubscriptionWhereInput
  ) => RatingSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  topic: (
    where?: TopicSubscriptionWhereInput
  ) => TopicSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  video: (
    where?: VideoSubscriptionWhereInput
  ) => VideoSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AccountActivationCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VideoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "ytId_ASC"
  | "ytId_DESC"
  | "complexity_ASC"
  | "complexity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TopicOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "value_ASC"
  | "value_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Complexity = "ELEMENTARY" | "BASIC" | "ADVANCED" | "EXPERT";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isActivated_ASC"
  | "isActivated_DESC"
  | "login_ASC"
  | "login_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PasswordResetCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PayloadOrderByInput =
  | "message_ASC"
  | "message_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RatingOrderByInput =
  | "votes_ASC"
  | "votes_DESC"
  | "total_ASC"
  | "total_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface VideoUpdateManyWithoutAdderInput {
  create?: VideoCreateWithoutAdderInput[] | VideoCreateWithoutAdderInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutAdderInput[]
    | VideoUpdateWithWhereUniqueWithoutAdderInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutAdderInput[]
    | VideoUpsertWithWhereUniqueWithoutAdderInput;
}

export type AccountActivationCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TopicUpsertWithWhereUniqueWithoutParentInput {
  where: TopicWhereUniqueInput;
  update: TopicUpdateWithoutParentDataInput;
  create: TopicCreateWithoutParentInput;
}

export interface AccountActivationCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  AND?: AccountActivationCodeWhereInput[] | AccountActivationCodeWhereInput;
  OR?: AccountActivationCodeWhereInput[] | AccountActivationCodeWhereInput;
  NOT?: AccountActivationCodeWhereInput[] | AccountActivationCodeWhereInput;
}

export interface TagUpdateManyWithoutParentInput {
  create?: TagCreateWithoutParentInput[] | TagCreateWithoutParentInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  update?:
    | TagUpdateWithWhereUniqueWithoutParentInput[]
    | TagUpdateWithWhereUniqueWithoutParentInput;
  upsert?:
    | TagUpsertWithWhereUniqueWithoutParentInput[]
    | TagUpsertWithWhereUniqueWithoutParentInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  activationCode?: AccountActivationCodeWhereInput;
  passwordResetCode?: PasswordResetCodeWhereInput;
  isActivated?: Boolean;
  isActivated_not?: Boolean;
  login?: String;
  login_not?: String;
  login_in?: String[] | String;
  login_not_in?: String[] | String;
  login_lt?: String;
  login_lte?: String;
  login_gt?: String;
  login_gte?: String;
  login_contains?: String;
  login_not_contains?: String;
  login_starts_with?: String;
  login_not_starts_with?: String;
  login_ends_with?: String;
  login_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  videosAdded_every?: VideoWhereInput;
  videosAdded_some?: VideoWhereInput;
  videosAdded_none?: VideoWhereInput;
  videosBookmarked_every?: VideoWhereInput;
  videosBookmarked_some?: VideoWhereInput;
  videosBookmarked_none?: VideoWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface PasswordResetCodeCreateOneWithoutUserInput {
  connect?: PasswordResetCodeWhereUniqueInput;
}

export interface UserCreateOneWithoutPasswordResetCodeInput {
  create?: UserCreateWithoutPasswordResetCodeInput;
  connect?: UserWhereUniqueInput;
}

export interface VideoCreateManyWithoutAdderInput {
  create?: VideoCreateWithoutAdderInput[] | VideoCreateWithoutAdderInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface TagUpdateWithWhereUniqueWithoutParentInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutParentDataInput;
}

export interface VideoCreateWithoutAdderInput {
  ytId: String;
  complexity: Complexity;
  topics?: TopicCreateManyWithoutParentInput;
  tags?: TagCreateManyWithoutParentInput;
  bookmarkers?: UserCreateManyWithoutVideosBookmarkedInput;
}

export interface TopicWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  parent_every?: VideoWhereInput;
  parent_some?: VideoWhereInput;
  parent_none?: VideoWhereInput;
  AND?: TopicWhereInput[] | TopicWhereInput;
  OR?: TopicWhereInput[] | TopicWhereInput;
  NOT?: TopicWhereInput[] | TopicWhereInput;
}

export interface TopicCreateManyWithoutParentInput {
  create?: TopicCreateWithoutParentInput[] | TopicCreateWithoutParentInput;
  connect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
}

export interface VideoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  ytId?: String;
  ytId_not?: String;
  ytId_in?: String[] | String;
  ytId_not_in?: String[] | String;
  ytId_lt?: String;
  ytId_lte?: String;
  ytId_gt?: String;
  ytId_gte?: String;
  ytId_contains?: String;
  ytId_not_contains?: String;
  ytId_starts_with?: String;
  ytId_not_starts_with?: String;
  ytId_ends_with?: String;
  ytId_not_ends_with?: String;
  complexity?: Complexity;
  complexity_not?: Complexity;
  complexity_in?: Complexity[] | Complexity;
  complexity_not_in?: Complexity[] | Complexity;
  topics_every?: TopicWhereInput;
  topics_some?: TopicWhereInput;
  topics_none?: TopicWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  adder?: UserWhereInput;
  bookmarkers_every?: UserWhereInput;
  bookmarkers_some?: UserWhereInput;
  bookmarkers_none?: UserWhereInput;
  AND?: VideoWhereInput[] | VideoWhereInput;
  OR?: VideoWhereInput[] | VideoWhereInput;
  NOT?: VideoWhereInput[] | VideoWhereInput;
}

export interface TopicCreateWithoutParentInput {
  value: String;
  text: String;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface TagCreateManyWithoutParentInput {
  create?: TagCreateWithoutParentInput[] | TagCreateWithoutParentInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface PayloadSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PayloadWhereInput;
  AND?: PayloadSubscriptionWhereInput[] | PayloadSubscriptionWhereInput;
  OR?: PayloadSubscriptionWhereInput[] | PayloadSubscriptionWhereInput;
  NOT?: PayloadSubscriptionWhereInput[] | PayloadSubscriptionWhereInput;
}

export interface TagCreateWithoutParentInput {
  value: String;
  text: String;
}

export type PasswordResetCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserCreateManyWithoutVideosBookmarkedInput {
  create?:
    | UserCreateWithoutVideosBookmarkedInput[]
    | UserCreateWithoutVideosBookmarkedInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface VideoUpdateInput {
  ytId?: String;
  complexity?: Complexity;
  topics?: TopicUpdateManyWithoutParentInput;
  tags?: TagUpdateManyWithoutParentInput;
  adder?: UserUpdateOneRequiredWithoutVideosAddedInput;
  bookmarkers?: UserUpdateManyWithoutVideosBookmarkedInput;
}

export interface UserCreateWithoutVideosBookmarkedInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  videosAdded?: VideoCreateManyWithoutAdderInput;
}

export interface UserUpdateInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  videosAdded?: VideoUpdateManyWithoutAdderInput;
  videosBookmarked?: VideoUpdateManyWithoutBookmarkersInput;
}

export interface AccountActivationCodeCreateOneWithoutUserInput {
  connect?: AccountActivationCodeWhereUniqueInput;
}

export interface UserCreateInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  videosAdded?: VideoCreateManyWithoutAdderInput;
  videosBookmarked?: VideoCreateManyWithoutBookmarkersInput;
}

export interface VideoCreateManyWithoutBookmarkersInput {
  create?:
    | VideoCreateWithoutBookmarkersInput[]
    | VideoCreateWithoutBookmarkersInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoUpdateWithoutTopicsDataInput {
  ytId?: String;
  complexity?: Complexity;
  tags?: TagUpdateManyWithoutParentInput;
  adder?: UserUpdateOneRequiredWithoutVideosAddedInput;
  bookmarkers?: UserUpdateManyWithoutVideosBookmarkedInput;
}

export interface VideoCreateWithoutBookmarkersInput {
  ytId: String;
  complexity: Complexity;
  topics?: TopicCreateManyWithoutParentInput;
  tags?: TagCreateManyWithoutParentInput;
  adder: UserCreateOneWithoutVideosAddedInput;
}

export interface VideoUpdateManyWithoutTopicsInput {
  create?: VideoCreateWithoutTopicsInput[] | VideoCreateWithoutTopicsInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutTopicsInput[]
    | VideoUpdateWithWhereUniqueWithoutTopicsInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutTopicsInput[]
    | VideoUpsertWithWhereUniqueWithoutTopicsInput;
}

export interface UserCreateOneWithoutVideosAddedInput {
  create?: UserCreateWithoutVideosAddedInput;
  connect?: UserWhereUniqueInput;
}

export interface TopicUpdateInput {
  value?: String;
  text?: String;
  parent?: VideoUpdateManyWithoutTopicsInput;
}

export interface UserCreateWithoutVideosAddedInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  videosBookmarked?: VideoCreateManyWithoutBookmarkersInput;
}

export interface VideoCreateManyWithoutTopicsInput {
  create?: VideoCreateWithoutTopicsInput[] | VideoCreateWithoutTopicsInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface AccountActivationCodeUpdateInput {
  user?: UserUpdateOneWithoutActivationCodeInput;
}

export interface VideoUpsertWithWhereUniqueWithoutTagsInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutTagsDataInput;
  create: VideoCreateWithoutTagsInput;
}

export interface UserUpdateOneWithoutActivationCodeInput {
  create?: UserCreateWithoutActivationCodeInput;
  update?: UserUpdateWithoutActivationCodeDataInput;
  upsert?: UserUpsertWithoutActivationCodeInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface VideoUpdateWithoutTagsDataInput {
  ytId?: String;
  complexity?: Complexity;
  topics?: TopicUpdateManyWithoutParentInput;
  adder?: UserUpdateOneRequiredWithoutVideosAddedInput;
  bookmarkers?: UserUpdateManyWithoutVideosBookmarkedInput;
}

export interface UserUpdateWithoutActivationCodeDataInput {
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  videosAdded?: VideoUpdateManyWithoutAdderInput;
  videosBookmarked?: VideoUpdateManyWithoutBookmarkersInput;
}

export interface VideoUpdateManyWithoutTagsInput {
  create?: VideoCreateWithoutTagsInput[] | VideoCreateWithoutTagsInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutTagsInput[]
    | VideoUpdateWithWhereUniqueWithoutTagsInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutTagsInput[]
    | VideoUpsertWithWhereUniqueWithoutTagsInput;
}

export interface PasswordResetCodeUpdateOneWithoutUserInput {
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PasswordResetCodeWhereUniqueInput;
}

export interface TagUpdateInput {
  value?: String;
  text?: String;
  parent?: VideoUpdateManyWithoutTagsInput;
}

export interface UserUpdateWithoutPasswordResetCodeDataInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  videosAdded?: VideoUpdateManyWithoutAdderInput;
  videosBookmarked?: VideoUpdateManyWithoutBookmarkersInput;
}

export interface VideoCreateManyWithoutTagsInput {
  create?: VideoCreateWithoutTagsInput[] | VideoCreateWithoutTagsInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface VideoUpdateWithWhereUniqueWithoutAdderInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutAdderDataInput;
}

export interface TagCreateInput {
  value: String;
  text: String;
  parent?: VideoCreateManyWithoutTagsInput;
}

export interface VideoUpdateWithoutAdderDataInput {
  ytId?: String;
  complexity?: Complexity;
  topics?: TopicUpdateManyWithoutParentInput;
  tags?: TagUpdateManyWithoutParentInput;
  bookmarkers?: UserUpdateManyWithoutVideosBookmarkedInput;
}

export interface RatingCreateInput {
  votes: Int;
  total: Int;
}

export interface TopicUpdateManyWithoutParentInput {
  create?: TopicCreateWithoutParentInput[] | TopicCreateWithoutParentInput;
  delete?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  connect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  disconnect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  update?:
    | TopicUpdateWithWhereUniqueWithoutParentInput[]
    | TopicUpdateWithWhereUniqueWithoutParentInput;
  upsert?:
    | TopicUpsertWithWhereUniqueWithoutParentInput[]
    | TopicUpsertWithWhereUniqueWithoutParentInput;
}

export interface PayloadUpdateInput {
  message?: String;
}

export interface TopicUpdateWithWhereUniqueWithoutParentInput {
  where: TopicWhereUniqueInput;
  data: TopicUpdateWithoutParentDataInput;
}

export interface UserUpsertWithoutPasswordResetCodeInput {
  update: UserUpdateWithoutPasswordResetCodeDataInput;
  create: UserCreateWithoutPasswordResetCodeInput;
}

export interface TopicUpdateWithoutParentDataInput {
  value?: String;
  text?: String;
}

export interface AccountActivationCodeCreateInput {
  user?: UserCreateOneWithoutActivationCodeInput;
}

export interface PasswordResetCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  AND?: PasswordResetCodeWhereInput[] | PasswordResetCodeWhereInput;
  OR?: PasswordResetCodeWhereInput[] | PasswordResetCodeWhereInput;
  NOT?: PasswordResetCodeWhereInput[] | PasswordResetCodeWhereInput;
}

export interface UserCreateWithoutActivationCodeInput {
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  videosAdded?: VideoCreateManyWithoutAdderInput;
  videosBookmarked?: VideoCreateManyWithoutBookmarkersInput;
}

export interface UserUpdateOneWithoutPasswordResetCodeInput {
  create?: UserCreateWithoutPasswordResetCodeInput;
  update?: UserUpdateWithoutPasswordResetCodeDataInput;
  upsert?: UserUpsertWithoutPasswordResetCodeInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  parent_every?: VideoWhereInput;
  parent_some?: VideoWhereInput;
  parent_none?: VideoWhereInput;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface RatingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RatingWhereInput;
  AND?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
  OR?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
  NOT?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
}

export interface TagUpdateWithoutParentDataInput {
  value?: String;
  text?: String;
}

export interface AccountActivationCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AccountActivationCodeWhereInput;
  AND?:
    | AccountActivationCodeSubscriptionWhereInput[]
    | AccountActivationCodeSubscriptionWhereInput;
  OR?:
    | AccountActivationCodeSubscriptionWhereInput[]
    | AccountActivationCodeSubscriptionWhereInput;
  NOT?:
    | AccountActivationCodeSubscriptionWhereInput[]
    | AccountActivationCodeSubscriptionWhereInput;
}

export interface TagUpsertWithWhereUniqueWithoutParentInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutParentDataInput;
  create: TagCreateWithoutParentInput;
}

export interface PayloadWhereInput {
  message?: String;
  message_not?: String;
  message_in?: String[] | String;
  message_not_in?: String[] | String;
  message_lt?: String;
  message_lte?: String;
  message_gt?: String;
  message_gte?: String;
  message_contains?: String;
  message_not_contains?: String;
  message_starts_with?: String;
  message_not_starts_with?: String;
  message_ends_with?: String;
  message_not_ends_with?: String;
  AND?: PayloadWhereInput[] | PayloadWhereInput;
  OR?: PayloadWhereInput[] | PayloadWhereInput;
  NOT?: PayloadWhereInput[] | PayloadWhereInput;
}

export interface UserUpdateManyWithoutVideosBookmarkedInput {
  create?:
    | UserCreateWithoutVideosBookmarkedInput[]
    | UserCreateWithoutVideosBookmarkedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutVideosBookmarkedInput[]
    | UserUpdateWithWhereUniqueWithoutVideosBookmarkedInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutVideosBookmarkedInput[]
    | UserUpsertWithWhereUniqueWithoutVideosBookmarkedInput;
}

export interface VideoUpdateWithWhereUniqueWithoutTopicsInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutTopicsDataInput;
}

export interface UserUpdateWithWhereUniqueWithoutVideosBookmarkedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutVideosBookmarkedDataInput;
}

export interface VideoCreateWithoutTopicsInput {
  ytId: String;
  complexity: Complexity;
  tags?: TagCreateManyWithoutParentInput;
  adder: UserCreateOneWithoutVideosAddedInput;
  bookmarkers?: UserCreateManyWithoutVideosBookmarkedInput;
}

export interface UserUpdateWithoutVideosBookmarkedDataInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  videosAdded?: VideoUpdateManyWithoutAdderInput;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  value?: String;
  text?: String;
}>;

export interface AccountActivationCodeUpdateOneWithoutUserInput {
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AccountActivationCodeWhereUniqueInput;
}

export type TopicWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  value?: String;
  text?: String;
}>;

export interface UserUpsertWithWhereUniqueWithoutVideosBookmarkedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutVideosBookmarkedDataInput;
  create: UserCreateWithoutVideosBookmarkedInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  login?: String;
  email?: String;
}>;

export interface VideoUpsertWithWhereUniqueWithoutAdderInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutAdderDataInput;
  create: VideoCreateWithoutAdderInput;
}

export type VideoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  ytId?: String;
}>;

export interface VideoUpdateManyWithoutBookmarkersInput {
  create?:
    | VideoCreateWithoutBookmarkersInput[]
    | VideoCreateWithoutBookmarkersInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutBookmarkersInput[]
    | VideoUpdateWithWhereUniqueWithoutBookmarkersInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutBookmarkersInput[]
    | VideoUpsertWithWhereUniqueWithoutBookmarkersInput;
}

export interface VideoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoWhereInput;
  AND?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  OR?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  NOT?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
}

export interface VideoUpdateWithWhereUniqueWithoutBookmarkersInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutBookmarkersDataInput;
}

export interface PasswordResetCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PasswordResetCodeWhereInput;
  AND?:
    | PasswordResetCodeSubscriptionWhereInput[]
    | PasswordResetCodeSubscriptionWhereInput;
  OR?:
    | PasswordResetCodeSubscriptionWhereInput[]
    | PasswordResetCodeSubscriptionWhereInput;
  NOT?:
    | PasswordResetCodeSubscriptionWhereInput[]
    | PasswordResetCodeSubscriptionWhereInput;
}

export interface VideoUpdateWithoutBookmarkersDataInput {
  ytId?: String;
  complexity?: Complexity;
  topics?: TopicUpdateManyWithoutParentInput;
  tags?: TagUpdateManyWithoutParentInput;
  adder?: UserUpdateOneRequiredWithoutVideosAddedInput;
}

export interface VideoUpsertWithWhereUniqueWithoutTopicsInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutTopicsDataInput;
  create: VideoCreateWithoutTopicsInput;
}

export interface UserUpdateOneRequiredWithoutVideosAddedInput {
  create?: UserCreateWithoutVideosAddedInput;
  update?: UserUpdateWithoutVideosAddedDataInput;
  upsert?: UserUpsertWithoutVideosAddedInput;
  connect?: UserWhereUniqueInput;
}

export interface TopicCreateInput {
  value: String;
  text: String;
  parent?: VideoCreateManyWithoutTopicsInput;
}

export interface UserUpdateWithoutVideosAddedDataInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  videosBookmarked?: VideoUpdateManyWithoutBookmarkersInput;
}

export interface VideoCreateWithoutTagsInput {
  ytId: String;
  complexity: Complexity;
  topics?: TopicCreateManyWithoutParentInput;
  adder: UserCreateOneWithoutVideosAddedInput;
  bookmarkers?: UserCreateManyWithoutVideosBookmarkedInput;
}

export interface UserUpsertWithoutVideosAddedInput {
  update: UserUpdateWithoutVideosAddedDataInput;
  create: UserCreateWithoutVideosAddedInput;
}

export interface PayloadCreateInput {
  message: String;
}

export interface VideoUpsertWithWhereUniqueWithoutBookmarkersInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutBookmarkersDataInput;
  create: VideoCreateWithoutBookmarkersInput;
}

export interface TopicSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TopicWhereInput;
  AND?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
  OR?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
  NOT?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
}

export interface PasswordResetCodeCreateInput {
  user?: UserCreateOneWithoutPasswordResetCodeInput;
}

export interface UserCreateWithoutPasswordResetCodeInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  videosAdded?: VideoCreateManyWithoutAdderInput;
  videosBookmarked?: VideoCreateManyWithoutBookmarkersInput;
}

export interface PasswordResetCodeUpdateInput {
  user?: UserUpdateOneWithoutPasswordResetCodeInput;
}

export interface UserUpsertWithoutActivationCodeInput {
  update: UserUpdateWithoutActivationCodeDataInput;
  create: UserCreateWithoutActivationCodeInput;
}

export interface VideoCreateInput {
  ytId: String;
  complexity: Complexity;
  topics?: TopicCreateManyWithoutParentInput;
  tags?: TagCreateManyWithoutParentInput;
  adder: UserCreateOneWithoutVideosAddedInput;
  bookmarkers?: UserCreateManyWithoutVideosBookmarkedInput;
}

export interface UserCreateOneWithoutActivationCodeInput {
  create?: UserCreateWithoutActivationCodeInput;
  connect?: UserWhereUniqueInput;
}

export interface RatingUpdateInput {
  votes?: Int;
  total?: Int;
}

export interface VideoUpdateWithWhereUniqueWithoutTagsInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutTagsDataInput;
}

export interface RatingWhereInput {
  votes?: Int;
  votes_not?: Int;
  votes_in?: Int[] | Int;
  votes_not_in?: Int[] | Int;
  votes_lt?: Int;
  votes_lte?: Int;
  votes_gt?: Int;
  votes_gte?: Int;
  total?: Int;
  total_not?: Int;
  total_in?: Int[] | Int;
  total_not_in?: Int[] | Int;
  total_lt?: Int;
  total_lte?: Int;
  total_gt?: Int;
  total_gte?: Int;
  AND?: RatingWhereInput[] | RatingWhereInput;
  OR?: RatingWhereInput[] | RatingWhereInput;
  NOT?: RatingWhereInput[] | RatingWhereInput;
}

export interface Node {
  id: ID_Output;
}

export interface VideoPreviousValues {
  id: ID_Output;
  ytId: String;
  complexity: Complexity;
}

export interface VideoPreviousValuesPromise
  extends Promise<VideoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  ytId: () => Promise<String>;
  complexity: () => Promise<Complexity>;
}

export interface VideoPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ytId: () => Promise<AsyncIterator<String>>;
  complexity: () => Promise<AsyncIterator<Complexity>>;
}

export interface PasswordResetCodeEdge {
  cursor: String;
}

export interface PasswordResetCodeEdgePromise
  extends Promise<PasswordResetCodeEdge>,
    Fragmentable {
  node: <T = PasswordResetCode>() => T;
  cursor: () => Promise<String>;
}

export interface PasswordResetCodeEdgeSubscription
  extends Promise<AsyncIterator<PasswordResetCodeEdge>>,
    Fragmentable {
  node: <T = PasswordResetCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Video {
  id: ID_Output;
  ytId: String;
  complexity: Complexity;
}

export interface VideoPromise extends Promise<Video>, Fragmentable {
  id: () => Promise<ID_Output>;
  ytId: () => Promise<String>;
  complexity: () => Promise<Complexity>;
  topics: <T = FragmentableArray<Topic>>(
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  adder: <T = User>() => T;
  bookmarkers: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface VideoSubscription
  extends Promise<AsyncIterator<Video>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  ytId: () => Promise<AsyncIterator<String>>;
  complexity: () => Promise<AsyncIterator<Complexity>>;
  topics: <T = Promise<AsyncIterator<TopicSubscription>>>(
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  adder: <T = UserSubscription>() => T;
  bookmarkers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregatePasswordResetCode {
  count: Int;
}

export interface AggregatePasswordResetCodePromise
  extends Promise<AggregatePasswordResetCode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePasswordResetCodeSubscription
  extends Promise<AsyncIterator<AggregatePasswordResetCode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface PasswordResetCodeConnection {}

export interface PasswordResetCodeConnectionPromise
  extends Promise<PasswordResetCodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PasswordResetCodeEdge>>() => T;
  aggregate: <T = AggregatePasswordResetCode>() => T;
}

export interface PasswordResetCodeConnectionSubscription
  extends Promise<AsyncIterator<PasswordResetCodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PasswordResetCodeEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePasswordResetCodeSubscription>() => T;
}

export interface VideoSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface VideoSubscriptionPayloadPromise
  extends Promise<VideoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Video>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoPreviousValues>() => T;
}

export interface VideoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoPreviousValuesSubscription>() => T;
}

export interface VideoEdge {
  cursor: String;
}

export interface VideoEdgePromise extends Promise<VideoEdge>, Fragmentable {
  node: <T = Video>() => T;
  cursor: () => Promise<String>;
}

export interface VideoEdgeSubscription
  extends Promise<AsyncIterator<VideoEdge>>,
    Fragmentable {
  node: <T = VideoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Topic {
  id: ID_Output;
  value: String;
  text: String;
}

export interface TopicPromise extends Promise<Topic>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  text: () => Promise<String>;
  parent: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TopicSubscription
  extends Promise<AsyncIterator<Topic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  parent: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AccountActivationCode {
  id: ID_Output;
}

export interface AccountActivationCodePromise
  extends Promise<AccountActivationCode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
}

export interface AccountActivationCodeSubscription
  extends Promise<AsyncIterator<AccountActivationCode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AccountActivationCodeSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AccountActivationCodeSubscriptionPayloadPromise
  extends Promise<AccountActivationCodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccountActivationCode>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccountActivationCodePreviousValues>() => T;
}

export interface AccountActivationCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccountActivationCodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccountActivationCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccountActivationCodePreviousValuesSubscription>() => T;
}

export interface TopicEdge {
  cursor: String;
}

export interface TopicEdgePromise extends Promise<TopicEdge>, Fragmentable {
  node: <T = Topic>() => T;
  cursor: () => Promise<String>;
}

export interface TopicEdgeSubscription
  extends Promise<AsyncIterator<TopicEdge>>,
    Fragmentable {
  node: <T = TopicSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AccountActivationCodePreviousValues {
  id: ID_Output;
}

export interface AccountActivationCodePreviousValuesPromise
  extends Promise<AccountActivationCodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface AccountActivationCodePreviousValuesSubscription
  extends Promise<AsyncIterator<AccountActivationCodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateAccountActivationCode {
  count: Int;
}

export interface AggregateAccountActivationCodePromise
  extends Promise<AggregateAccountActivationCode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccountActivationCodeSubscription
  extends Promise<AsyncIterator<AggregateAccountActivationCode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTag>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface PasswordResetCodeSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PasswordResetCodeSubscriptionPayloadPromise
  extends Promise<PasswordResetCodeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PasswordResetCode>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PasswordResetCodePreviousValues>() => T;
}

export interface PasswordResetCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PasswordResetCodeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PasswordResetCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PasswordResetCodePreviousValuesSubscription>() => T;
}

export interface RatingEdge {
  cursor: String;
}

export interface RatingEdgePromise extends Promise<RatingEdge>, Fragmentable {
  node: <T = Rating>() => T;
  cursor: () => Promise<String>;
}

export interface RatingEdgeSubscription
  extends Promise<AsyncIterator<RatingEdge>>,
    Fragmentable {
  node: <T = RatingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PasswordResetCodePreviousValues {
  id: ID_Output;
}

export interface PasswordResetCodePreviousValuesPromise
  extends Promise<PasswordResetCodePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface PasswordResetCodePreviousValuesSubscription
  extends Promise<AsyncIterator<PasswordResetCodePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Rating {
  votes: Int;
  total: Int;
}

export interface RatingPromise extends Promise<Rating>, Fragmentable {
  votes: () => Promise<Int>;
  total: () => Promise<Int>;
}

export interface RatingSubscription
  extends Promise<AsyncIterator<Rating>>,
    Fragmentable {
  votes: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
}

export interface AccountActivationCodeEdge {
  cursor: String;
}

export interface AccountActivationCodeEdgePromise
  extends Promise<AccountActivationCodeEdge>,
    Fragmentable {
  node: <T = AccountActivationCode>() => T;
  cursor: () => Promise<String>;
}

export interface AccountActivationCodeEdgeSubscription
  extends Promise<AsyncIterator<AccountActivationCodeEdge>>,
    Fragmentable {
  node: <T = AccountActivationCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePayload {
  count: Int;
}

export interface AggregatePayloadPromise
  extends Promise<AggregatePayload>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePayloadSubscription
  extends Promise<AsyncIterator<AggregatePayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PayloadSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PayloadSubscriptionPayloadPromise
  extends Promise<PayloadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Payload>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PayloadPreviousValues>() => T;
}

export interface PayloadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PayloadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PayloadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PayloadPreviousValuesSubscription>() => T;
}

export interface PayloadConnection {}

export interface PayloadConnectionPromise
  extends Promise<PayloadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PayloadEdge>>() => T;
  aggregate: <T = AggregatePayload>() => T;
}

export interface PayloadConnectionSubscription
  extends Promise<AsyncIterator<PayloadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PayloadEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePayloadSubscription>() => T;
}

export interface PayloadPreviousValues {
  message: String;
}

export interface PayloadPreviousValuesPromise
  extends Promise<PayloadPreviousValues>,
    Fragmentable {
  message: () => Promise<String>;
}

export interface PayloadPreviousValuesSubscription
  extends Promise<AsyncIterator<PayloadPreviousValues>>,
    Fragmentable {
  message: () => Promise<AsyncIterator<String>>;
}

export interface PasswordResetCode {
  id: ID_Output;
}

export interface PasswordResetCodePromise
  extends Promise<PasswordResetCode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
}

export interface PasswordResetCodeSubscription
  extends Promise<AsyncIterator<PasswordResetCode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface VideoConnection {}

export interface VideoConnectionPromise
  extends Promise<VideoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<VideoEdge>>() => T;
  aggregate: <T = AggregateVideo>() => T;
}

export interface VideoConnectionSubscription
  extends Promise<AsyncIterator<VideoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoSubscription>() => T;
}

export interface RatingSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RatingSubscriptionPayloadPromise
  extends Promise<RatingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Rating>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RatingPreviousValues>() => T;
}

export interface RatingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RatingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RatingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RatingPreviousValuesSubscription>() => T;
}

export interface AggregateTopic {
  count: Int;
}

export interface AggregateTopicPromise
  extends Promise<AggregateTopic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopicSubscription
  extends Promise<AsyncIterator<AggregateTopic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RatingPreviousValues {
  votes: Int;
  total: Int;
}

export interface RatingPreviousValuesPromise
  extends Promise<RatingPreviousValues>,
    Fragmentable {
  votes: () => Promise<Int>;
  total: () => Promise<Int>;
}

export interface RatingPreviousValuesSubscription
  extends Promise<AsyncIterator<RatingPreviousValues>>,
    Fragmentable {
  votes: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
}

export interface TagEdge {
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = Tag>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AccountActivationCodeConnection {}

export interface AccountActivationCodeConnectionPromise
  extends Promise<AccountActivationCodeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<AccountActivationCodeEdge>>() => T;
  aggregate: <T = AggregateAccountActivationCode>() => T;
}

export interface AccountActivationCodeConnectionSubscription
  extends Promise<AsyncIterator<AccountActivationCodeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<AccountActivationCodeEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateAccountActivationCodeSubscription>() => T;
}

export interface RatingConnection {}

export interface RatingConnectionPromise
  extends Promise<RatingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<RatingEdge>>() => T;
  aggregate: <T = AggregateRating>() => T;
}

export interface RatingConnectionSubscription
  extends Promise<AsyncIterator<RatingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RatingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRatingSubscription>() => T;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Tag>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValues>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface PayloadEdge {
  cursor: String;
}

export interface PayloadEdgePromise extends Promise<PayloadEdge>, Fragmentable {
  node: <T = Payload>() => T;
  cursor: () => Promise<String>;
}

export interface PayloadEdgeSubscription
  extends Promise<AsyncIterator<PayloadEdge>>,
    Fragmentable {
  node: <T = PayloadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TagPreviousValues {
  id: ID_Output;
  value: String;
  text: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  text: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideo {
  count: Int;
}

export interface AggregateVideoPromise
  extends Promise<AggregateVideo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoSubscription
  extends Promise<AsyncIterator<AggregateVideo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TopicConnection {}

export interface TopicConnectionPromise
  extends Promise<TopicConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<TopicEdge>>() => T;
  aggregate: <T = AggregateTopic>() => T;
}

export interface TopicConnectionSubscription
  extends Promise<AsyncIterator<TopicConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TopicEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTopicSubscription>() => T;
}

export interface Tag {
  id: ID_Output;
  value: String;
  text: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  text: () => Promise<String>;
  parent: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  parent: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TopicPreviousValues {
  id: ID_Output;
  value: String;
  text: String;
}

export interface TopicPreviousValuesPromise
  extends Promise<TopicPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  value: () => Promise<String>;
  text: () => Promise<String>;
}

export interface TopicPreviousValuesSubscription
  extends Promise<AsyncIterator<TopicPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface TopicSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TopicSubscriptionPayloadPromise
  extends Promise<TopicSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Topic>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TopicPreviousValues>() => T;
}

export interface TopicSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopicSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopicSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TopicPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isActivated: () => Promise<Boolean>;
  login: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isActivated: () => Promise<AsyncIterator<Boolean>>;
  login: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRating {
  count: Int;
}

export interface AggregateRatingPromise
  extends Promise<AggregateRating>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRatingSubscription
  extends Promise<AsyncIterator<AggregateRating>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Payload {
  message: String;
}

export interface PayloadPromise extends Promise<Payload>, Fragmentable {
  message: () => Promise<String>;
}

export interface PayloadSubscription
  extends Promise<AsyncIterator<Payload>>,
    Fragmentable {
  message: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  activationCode: <T = AccountActivationCode>() => T;
  passwordResetCode: <T = PasswordResetCode>() => T;
  isActivated: () => Promise<Boolean>;
  login: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  videosAdded: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  videosBookmarked: <T = FragmentableArray<Video>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  activationCode: <T = AccountActivationCodeSubscription>() => T;
  passwordResetCode: <T = PasswordResetCodeSubscription>() => T;
  isActivated: () => Promise<AsyncIterator<Boolean>>;
  login: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  videosAdded: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  videosBookmarked: <T = Promise<AsyncIterator<VideoSubscription>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`
});
export const prisma = new Prisma();
