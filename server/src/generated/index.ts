// Code generated by Prisma (prisma@1.17.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  accountActivationCode: (
    where?: AccountActivationCodeWhereInput
  ) => Promise<boolean>;
  passwordResetCode: (where?: PasswordResetCodeWhereInput) => Promise<boolean>;
  rating: (where?: RatingWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  tags: (where?: TagsWhereInput) => Promise<boolean>;
  topic: (where?: TopicWhereInput) => Promise<boolean>;
  topics: (where?: TopicsWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  video: (where?: VideoWhereInput) => Promise<boolean>;
}

export interface Node {}

export interface Fragmentable {
  $fragment<T>(fragment: string | Object): T;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;
  $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;

  /**
   * Queries
   */

  accountActivationCode: (
    where: AccountActivationCodeWhereUniqueInput
  ) => AccountActivationCode;
  accountActivationCodes: (
    args?: {
      where?: AccountActivationCodeWhereInput;
      orderBy?: AccountActivationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<AccountActivationCodeNode>>;
  accountActivationCodesConnection: (
    args?: {
      where?: AccountActivationCodeWhereInput;
      orderBy?: AccountActivationCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AccountActivationCodeConnection;
  passwordResetCode: (
    where: PasswordResetCodeWhereUniqueInput
  ) => PasswordResetCode;
  passwordResetCodes: (
    args?: {
      where?: PasswordResetCodeWhereInput;
      orderBy?: PasswordResetCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<PasswordResetCodeNode>>;
  passwordResetCodesConnection: (
    args?: {
      where?: PasswordResetCodeWhereInput;
      orderBy?: PasswordResetCodeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PasswordResetCodeConnection;
  ratings: (
    args?: {
      where?: RatingWhereInput;
      orderBy?: RatingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<RatingNode>>;
  ratingsConnection: (
    args?: {
      where?: RatingWhereInput;
      orderBy?: RatingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RatingConnection;
  tag: (where: TagWhereUniqueInput) => Tag;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<TagNode>>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnection;
  tagses: (
    args?: {
      where?: TagsWhereInput;
      orderBy?: TagsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<TagsNode>>;
  tagsesConnection: (
    args?: {
      where?: TagsWhereInput;
      orderBy?: TagsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagsConnection;
  topic: (where: TopicWhereUniqueInput) => Topic;
  topics: (
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<TopicNode>>;
  topicsConnection: (
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TopicConnection;
  topicses: (
    args?: {
      where?: TopicsWhereInput;
      orderBy?: TopicsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<TopicsNode>>;
  topicsesConnection: (
    args?: {
      where?: TopicsWhereInput;
      orderBy?: TopicsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TopicsConnection;
  user: (where: UserWhereUniqueInput) => User;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<UserNode>>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnection;
  video: (where: VideoWhereUniqueInput) => Video;
  videos: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<VideoNode>>;
  videosConnection: (
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VideoConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAccountActivationCode: (
    data: AccountActivationCodeCreateInput
  ) => AccountActivationCode;
  updateAccountActivationCode: (
    args: {
      data: AccountActivationCodeUpdateInput;
      where: AccountActivationCodeWhereUniqueInput;
    }
  ) => AccountActivationCode;
  updateManyAccountActivationCodes: (
    args: {
      data: AccountActivationCodeUpdateInput;
      where?: AccountActivationCodeWhereInput;
    }
  ) => BatchPayload;
  upsertAccountActivationCode: (
    args: {
      where: AccountActivationCodeWhereUniqueInput;
      create: AccountActivationCodeCreateInput;
      update: AccountActivationCodeUpdateInput;
    }
  ) => AccountActivationCode;
  deleteAccountActivationCode: (
    where: AccountActivationCodeWhereUniqueInput
  ) => AccountActivationCode;
  deleteManyAccountActivationCodes: (
    where?: AccountActivationCodeWhereInput
  ) => BatchPayload;
  createPasswordResetCode: (
    data: PasswordResetCodeCreateInput
  ) => PasswordResetCode;
  updatePasswordResetCode: (
    args: {
      data: PasswordResetCodeUpdateInput;
      where: PasswordResetCodeWhereUniqueInput;
    }
  ) => PasswordResetCode;
  updateManyPasswordResetCodes: (
    args: {
      data: PasswordResetCodeUpdateInput;
      where?: PasswordResetCodeWhereInput;
    }
  ) => BatchPayload;
  upsertPasswordResetCode: (
    args: {
      where: PasswordResetCodeWhereUniqueInput;
      create: PasswordResetCodeCreateInput;
      update: PasswordResetCodeUpdateInput;
    }
  ) => PasswordResetCode;
  deletePasswordResetCode: (
    where: PasswordResetCodeWhereUniqueInput
  ) => PasswordResetCode;
  deleteManyPasswordResetCodes: (
    where?: PasswordResetCodeWhereInput
  ) => BatchPayload;
  createRating: (data: RatingCreateInput) => Rating;
  updateManyRatings: (
    args: { data: RatingUpdateInput; where?: RatingWhereInput }
  ) => BatchPayload;
  deleteManyRatings: (where?: RatingWhereInput) => BatchPayload;
  createTag: (data: TagCreateInput) => Tag;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => Tag;
  updateManyTags: (
    args: { data: TagUpdateInput; where?: TagWhereInput }
  ) => BatchPayload;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => Tag;
  deleteTag: (where: TagWhereUniqueInput) => Tag;
  deleteManyTags: (where?: TagWhereInput) => BatchPayload;
  createTags: (data: TagsCreateInput) => Tags;
  updateManyTagses: (
    args: { data: TagsUpdateInput; where?: TagsWhereInput }
  ) => BatchPayload;
  deleteManyTagses: (where?: TagsWhereInput) => BatchPayload;
  createTopic: (data: TopicCreateInput) => Topic;
  updateTopic: (
    args: { data: TopicUpdateInput; where: TopicWhereUniqueInput }
  ) => Topic;
  updateManyTopics: (
    args: { data: TopicUpdateInput; where?: TopicWhereInput }
  ) => BatchPayload;
  upsertTopic: (
    args: {
      where: TopicWhereUniqueInput;
      create: TopicCreateInput;
      update: TopicUpdateInput;
    }
  ) => Topic;
  deleteTopic: (where: TopicWhereUniqueInput) => Topic;
  deleteManyTopics: (where?: TopicWhereInput) => BatchPayload;
  createTopics: (data: TopicsCreateInput) => Topics;
  updateManyTopicses: (
    args: { data: TopicsUpdateInput; where?: TopicsWhereInput }
  ) => BatchPayload;
  deleteManyTopicses: (where?: TopicsWhereInput) => BatchPayload;
  createUser: (data: UserCreateInput) => User;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => User;
  updateManyUsers: (
    args: { data: UserUpdateInput; where?: UserWhereInput }
  ) => BatchPayload;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => User;
  deleteUser: (where: UserWhereUniqueInput) => User;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayload;
  createVideo: (data: VideoCreateInput) => Video;
  updateVideo: (
    args: { data: VideoUpdateInput; where: VideoWhereUniqueInput }
  ) => Video;
  updateManyVideos: (
    args: { data: VideoUpdateInput; where?: VideoWhereInput }
  ) => BatchPayload;
  upsertVideo: (
    args: {
      where: VideoWhereUniqueInput;
      create: VideoCreateInput;
      update: VideoUpdateInput;
    }
  ) => Video;
  deleteVideo: (where: VideoWhereUniqueInput) => Video;
  deleteManyVideos: (where?: VideoWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  accountActivationCode: (
    where?: AccountActivationCodeSubscriptionWhereInput
  ) => AccountActivationCodeSubscriptionPayloadSubscription;
  passwordResetCode: (
    where?: PasswordResetCodeSubscriptionWhereInput
  ) => PasswordResetCodeSubscriptionPayloadSubscription;
  rating: (
    where?: RatingSubscriptionWhereInput
  ) => RatingSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  tags: (
    where?: TagsSubscriptionWhereInput
  ) => TagsSubscriptionPayloadSubscription;
  topic: (
    where?: TopicSubscriptionWhereInput
  ) => TopicSubscriptionPayloadSubscription;
  topics: (
    where?: TopicsSubscriptionWhereInput
  ) => TopicsSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  video: (
    where?: VideoSubscriptionWhereInput
  ) => VideoSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AccountActivationCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VideoOrderByInput =
  | "ytId_ASC"
  | "ytId_DESC"
  | "complexity_ASC"
  | "complexity_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TopicOrderByInput =
  | "value_ASC"
  | "value_DESC"
  | "text_ASC"
  | "text_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TagOrderByInput =
  | "value_ASC"
  | "value_DESC"
  | "text_ASC"
  | "text_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isActivated_ASC"
  | "isActivated_DESC"
  | "login_ASC"
  | "login_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Complexity = "ELEMENTARY" | "BASIC" | "ADVANCED" | "EXPERT";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PasswordResetCodeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RatingOrderByInput =
  | "votes_ASC"
  | "votes_DESC"
  | "total_ASC"
  | "total_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TagsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TopicsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface VideoCreateManyWithoutBookmarkersInput {
  create?:
    | VideoCreateWithoutBookmarkersInput[]
    | VideoCreateWithoutBookmarkersInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export type AccountActivationCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithoutActivationCodeDataInput {
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  myVideos?: VideoUpdateManyWithoutAdderInput;
  bookmarkedVideos?: VideoUpdateManyWithoutBookmarkersInput;
}

export interface PasswordResetCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  AND?: PasswordResetCodeWhereInput[] | PasswordResetCodeWhereInput;
  OR?: PasswordResetCodeWhereInput[] | PasswordResetCodeWhereInput;
  NOT?: PasswordResetCodeWhereInput[] | PasswordResetCodeWhereInput;
}

export interface UserUpdateWithoutMyVideosDataInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  bookmarkedVideos?: VideoUpdateManyWithoutBookmarkersInput;
}

export interface UserUpdateWithoutBookmarkedVideosDataInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  myVideos?: VideoUpdateManyWithoutAdderInput;
}

export interface UserUpdateOneRequiredWithoutMyVideosInput {
  create?: UserCreateWithoutMyVideosInput;
  update?: UserUpdateWithoutMyVideosDataInput;
  upsert?: UserUpsertWithoutMyVideosInput;
  connect?: UserWhereUniqueInput;
}

export interface PasswordResetCodeUpdateOneWithoutUserInput {
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PasswordResetCodeWhereUniqueInput;
}

export interface VideoUpdateWithoutBookmarkersDataInput {
  ytId?: String;
  complexity?: Complexity;
  topics?: TopicUpdateManyInput;
  tags?: TagUpdateManyInput;
  adder?: UserUpdateOneRequiredWithoutMyVideosInput;
}

export interface VideoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VideoWhereInput;
  AND?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  OR?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
  NOT?: VideoSubscriptionWhereInput[] | VideoSubscriptionWhereInput;
}

export type VideoWhereUniqueInput = AtLeastOne<{
  ytId: String;
}>;

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface VideoUpdateWithWhereUniqueWithoutBookmarkersInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutBookmarkersDataInput;
}

export interface VideoWhereInput {
  ytId?: String;
  ytId_not?: String;
  ytId_in?: String[] | String;
  ytId_not_in?: String[] | String;
  ytId_lt?: String;
  ytId_lte?: String;
  ytId_gt?: String;
  ytId_gte?: String;
  ytId_contains?: String;
  ytId_not_contains?: String;
  ytId_starts_with?: String;
  ytId_not_starts_with?: String;
  ytId_ends_with?: String;
  ytId_not_ends_with?: String;
  complexity?: Complexity;
  complexity_not?: Complexity;
  complexity_in?: Complexity[] | Complexity;
  complexity_not_in?: Complexity[] | Complexity;
  topics_every?: TopicWhereInput;
  topics_some?: TopicWhereInput;
  topics_none?: TopicWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  adder?: UserWhereInput;
  bookmarkers_every?: UserWhereInput;
  bookmarkers_some?: UserWhereInput;
  bookmarkers_none?: UserWhereInput;
  AND?: VideoWhereInput[] | VideoWhereInput;
  OR?: VideoWhereInput[] | VideoWhereInput;
  NOT?: VideoWhereInput[] | VideoWhereInput;
}

export interface VideoUpdateManyWithoutBookmarkersInput {
  create?:
    | VideoCreateWithoutBookmarkersInput[]
    | VideoCreateWithoutBookmarkersInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutBookmarkersInput[]
    | VideoUpdateWithWhereUniqueWithoutBookmarkersInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutBookmarkersInput[]
    | VideoUpsertWithWhereUniqueWithoutBookmarkersInput;
}

export interface TopicSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TopicWhereInput;
  AND?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
  OR?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
  NOT?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
}

export interface VideoUpsertWithWhereUniqueWithoutAdderInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutAdderDataInput;
  create: VideoCreateWithoutAdderInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface RatingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RatingWhereInput;
  AND?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
  OR?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
  NOT?: RatingSubscriptionWhereInput[] | RatingSubscriptionWhereInput;
}

export interface AccountActivationCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AccountActivationCodeWhereInput;
  AND?:
    | AccountActivationCodeSubscriptionWhereInput[]
    | AccountActivationCodeSubscriptionWhereInput;
  OR?:
    | AccountActivationCodeSubscriptionWhereInput[]
    | AccountActivationCodeSubscriptionWhereInput;
  NOT?:
    | AccountActivationCodeSubscriptionWhereInput[]
    | AccountActivationCodeSubscriptionWhereInput;
}

export interface AccountActivationCodeCreateInput {
  user?: UserCreateOneWithoutActivationCodeInput;
}

export interface RatingWhereInput {
  votes?: Int;
  votes_not?: Int;
  votes_in?: Int[] | Int;
  votes_not_in?: Int[] | Int;
  votes_lt?: Int;
  votes_lte?: Int;
  votes_gt?: Int;
  votes_gte?: Int;
  total?: Int;
  total_not?: Int;
  total_in?: Int[] | Int;
  total_not_in?: Int[] | Int;
  total_lt?: Int;
  total_lte?: Int;
  total_gt?: Int;
  total_gte?: Int;
  AND?: RatingWhereInput[] | RatingWhereInput;
  OR?: RatingWhereInput[] | RatingWhereInput;
  NOT?: RatingWhereInput[] | RatingWhereInput;
}

export interface UserCreateOneWithoutActivationCodeInput {
  create?: UserCreateWithoutActivationCodeInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  myVideos?: VideoUpdateManyWithoutAdderInput;
  bookmarkedVideos?: VideoUpdateManyWithoutBookmarkersInput;
}

export interface UserCreateWithoutActivationCodeInput {
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  myVideos?: VideoCreateManyWithoutAdderInput;
  bookmarkedVideos?: VideoCreateManyWithoutBookmarkersInput;
}

export interface TopicsUpdateInput {
  exist?: TopicUpdateManyInput;
}

export interface PasswordResetCodeCreateOneWithoutUserInput {
  connect?: PasswordResetCodeWhereUniqueInput;
}

export type TagWhereUniqueInput = AtLeastOne<{
  value: String;
  text?: String;
}>;

export interface VideoCreateManyWithoutAdderInput {
  create?: VideoCreateWithoutAdderInput[] | VideoCreateWithoutAdderInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
}

export interface TagsUpdateInput {
  exist?: TagUpdateManyInput;
}

export interface VideoCreateWithoutAdderInput {
  ytId: String;
  complexity: Complexity;
  topics?: TopicCreateManyInput;
  tags?: TagCreateManyInput;
  bookmarkers?: UserCreateManyWithoutBookmarkedVideosInput;
}

export interface TagsWhereInput {
  exist_every?: TagWhereInput;
  exist_some?: TagWhereInput;
  exist_none?: TagWhereInput;
  AND?: TagsWhereInput[] | TagsWhereInput;
  OR?: TagsWhereInput[] | TagsWhereInput;
  NOT?: TagsWhereInput[] | TagsWhereInput;
}

export interface TopicCreateManyInput {
  create?: TopicCreateInput[] | TopicCreateInput;
  connect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
}

export interface RatingUpdateInput {
  votes?: Int;
  total?: Int;
}

export interface TopicCreateInput {
  value: String;
  text: String;
}

export interface UserUpsertWithoutPasswordResetCodeInput {
  update: UserUpdateWithoutPasswordResetCodeDataInput;
  create: UserCreateWithoutPasswordResetCodeInput;
}

export interface TagCreateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export type TopicWhereUniqueInput = AtLeastOne<{
  value: String;
  text?: String;
}>;

export interface TagCreateInput {
  value: String;
  text: String;
}

export interface PasswordResetCodeUpdateInput {
  user?: UserUpdateOneWithoutPasswordResetCodeInput;
}

export interface UserCreateManyWithoutBookmarkedVideosInput {
  create?:
    | UserCreateWithoutBookmarkedVideosInput[]
    | UserCreateWithoutBookmarkedVideosInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface TopicsWhereInput {
  exist_every?: TopicWhereInput;
  exist_some?: TopicWhereInput;
  exist_none?: TopicWhereInput;
  AND?: TopicsWhereInput[] | TopicsWhereInput;
  OR?: TopicsWhereInput[] | TopicsWhereInput;
  NOT?: TopicsWhereInput[] | TopicsWhereInput;
}

export interface UserCreateWithoutBookmarkedVideosInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  myVideos?: VideoCreateManyWithoutAdderInput;
}

export interface PasswordResetCodeCreateInput {
  user?: UserCreateOneWithoutPasswordResetCodeInput;
}

export interface AccountActivationCodeCreateOneWithoutUserInput {
  connect?: AccountActivationCodeWhereUniqueInput;
}

export interface VideoUpsertWithWhereUniqueWithoutBookmarkersInput {
  where: VideoWhereUniqueInput;
  update: VideoUpdateWithoutBookmarkersDataInput;
  create: VideoCreateWithoutBookmarkersInput;
}

export interface UserUpsertWithWhereUniqueWithoutBookmarkedVideosInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutBookmarkedVideosDataInput;
  create: UserCreateWithoutBookmarkedVideosInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  login?: String;
  email?: String;
}>;

export interface VideoCreateWithoutBookmarkersInput {
  ytId: String;
  complexity: Complexity;
  topics?: TopicCreateManyInput;
  tags?: TagCreateManyInput;
  adder: UserCreateOneWithoutMyVideosInput;
}

export interface TagWhereInput {
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface UserCreateOneWithoutMyVideosInput {
  create?: UserCreateWithoutMyVideosInput;
  connect?: UserWhereUniqueInput;
}

export interface TopicsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TopicsWhereInput;
  AND?: TopicsSubscriptionWhereInput[] | TopicsSubscriptionWhereInput;
  OR?: TopicsSubscriptionWhereInput[] | TopicsSubscriptionWhereInput;
  NOT?: TopicsSubscriptionWhereInput[] | TopicsSubscriptionWhereInput;
}

export interface UserCreateWithoutMyVideosInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  bookmarkedVideos?: VideoCreateManyWithoutBookmarkersInput;
}

export type PasswordResetCodeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AccountActivationCodeUpdateInput {
  user?: UserUpdateOneWithoutActivationCodeInput;
}

export interface VideoUpdateInput {
  ytId?: String;
  complexity?: Complexity;
  topics?: TopicUpdateManyInput;
  tags?: TagUpdateManyInput;
  adder?: UserUpdateOneRequiredWithoutMyVideosInput;
  bookmarkers?: UserUpdateManyWithoutBookmarkedVideosInput;
}

export interface UserUpdateOneWithoutActivationCodeInput {
  create?: UserCreateWithoutActivationCodeInput;
  update?: UserUpdateWithoutActivationCodeDataInput;
  upsert?: UserUpsertWithoutActivationCodeInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  passwordResetCode?: PasswordResetCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  myVideos?: VideoCreateManyWithoutAdderInput;
  bookmarkedVideos?: VideoCreateManyWithoutBookmarkersInput;
}

export interface AccountActivationCodeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  AND?: AccountActivationCodeWhereInput[] | AccountActivationCodeWhereInput;
  OR?: AccountActivationCodeWhereInput[] | AccountActivationCodeWhereInput;
  NOT?: AccountActivationCodeWhereInput[] | AccountActivationCodeWhereInput;
}

export interface TopicUpdateInput {
  value?: String;
  text?: String;
}

export interface AccountActivationCodeUpdateOneWithoutUserInput {
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AccountActivationCodeWhereUniqueInput;
}

export interface TagUpdateInput {
  value?: String;
  text?: String;
}

export interface VideoUpdateManyWithoutAdderInput {
  create?: VideoCreateWithoutAdderInput[] | VideoCreateWithoutAdderInput;
  delete?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  connect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  disconnect?: VideoWhereUniqueInput[] | VideoWhereUniqueInput;
  update?:
    | VideoUpdateWithWhereUniqueWithoutAdderInput[]
    | VideoUpdateWithWhereUniqueWithoutAdderInput;
  upsert?:
    | VideoUpsertWithWhereUniqueWithoutAdderInput[]
    | VideoUpsertWithWhereUniqueWithoutAdderInput;
}

export interface UserUpdateWithoutPasswordResetCodeDataInput {
  activationCode?: AccountActivationCodeUpdateOneWithoutUserInput;
  isActivated?: Boolean;
  login?: String;
  email?: String;
  password?: String;
  name?: String;
  myVideos?: VideoUpdateManyWithoutAdderInput;
  bookmarkedVideos?: VideoUpdateManyWithoutBookmarkersInput;
}

export interface VideoUpdateWithWhereUniqueWithoutAdderInput {
  where: VideoWhereUniqueInput;
  data: VideoUpdateWithoutAdderDataInput;
}

export interface UserCreateWithoutPasswordResetCodeInput {
  activationCode?: AccountActivationCodeCreateOneWithoutUserInput;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
  myVideos?: VideoCreateManyWithoutAdderInput;
  bookmarkedVideos?: VideoCreateManyWithoutBookmarkersInput;
}

export interface VideoUpdateWithoutAdderDataInput {
  ytId?: String;
  complexity?: Complexity;
  topics?: TopicUpdateManyInput;
  tags?: TagUpdateManyInput;
  bookmarkers?: UserUpdateManyWithoutBookmarkedVideosInput;
}

export interface UserUpsertWithoutActivationCodeInput {
  update: UserUpdateWithoutActivationCodeDataInput;
  create: UserCreateWithoutActivationCodeInput;
}

export interface TopicUpdateManyInput {
  create?: TopicCreateInput[] | TopicCreateInput;
  delete?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  connect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  disconnect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  update?:
    | TopicUpdateWithWhereUniqueNestedInput[]
    | TopicUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TopicUpsertWithWhereUniqueNestedInput[]
    | TopicUpsertWithWhereUniqueNestedInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  activationCode?: AccountActivationCodeWhereInput;
  passwordResetCode?: PasswordResetCodeWhereInput;
  isActivated?: Boolean;
  isActivated_not?: Boolean;
  login?: String;
  login_not?: String;
  login_in?: String[] | String;
  login_not_in?: String[] | String;
  login_lt?: String;
  login_lte?: String;
  login_gt?: String;
  login_gte?: String;
  login_contains?: String;
  login_not_contains?: String;
  login_starts_with?: String;
  login_not_starts_with?: String;
  login_ends_with?: String;
  login_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  myVideos_every?: VideoWhereInput;
  myVideos_some?: VideoWhereInput;
  myVideos_none?: VideoWhereInput;
  bookmarkedVideos_every?: VideoWhereInput;
  bookmarkedVideos_some?: VideoWhereInput;
  bookmarkedVideos_none?: VideoWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface TopicUpdateWithWhereUniqueNestedInput {
  where: TopicWhereUniqueInput;
  data: TopicUpdateDataInput;
}

export interface TagsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagsWhereInput;
  AND?: TagsSubscriptionWhereInput[] | TagsSubscriptionWhereInput;
  OR?: TagsSubscriptionWhereInput[] | TagsSubscriptionWhereInput;
  NOT?: TagsSubscriptionWhereInput[] | TagsSubscriptionWhereInput;
}

export interface TopicUpdateDataInput {
  value?: String;
  text?: String;
}

export interface VideoCreateInput {
  ytId: String;
  complexity: Complexity;
  topics?: TopicCreateManyInput;
  tags?: TagCreateManyInput;
  adder: UserCreateOneWithoutMyVideosInput;
  bookmarkers?: UserCreateManyWithoutBookmarkedVideosInput;
}

export interface TopicUpsertWithWhereUniqueNestedInput {
  where: TopicWhereUniqueInput;
  update: TopicUpdateDataInput;
  create: TopicCreateInput;
}

export interface TagsCreateInput {
  exist?: TagCreateManyInput;
}

export interface TagUpdateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  update?:
    | TagUpdateWithWhereUniqueNestedInput[]
    | TagUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TagUpsertWithWhereUniqueNestedInput[]
    | TagUpsertWithWhereUniqueNestedInput;
}

export interface UserUpdateOneWithoutPasswordResetCodeInput {
  create?: UserCreateWithoutPasswordResetCodeInput;
  update?: UserUpdateWithoutPasswordResetCodeDataInput;
  upsert?: UserUpsertWithoutPasswordResetCodeInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface UserUpsertWithoutMyVideosInput {
  update: UserUpdateWithoutMyVideosDataInput;
  create: UserCreateWithoutMyVideosInput;
}

export interface UserUpdateWithWhereUniqueWithoutBookmarkedVideosInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutBookmarkedVideosDataInput;
}

export interface UserUpdateManyWithoutBookmarkedVideosInput {
  create?:
    | UserCreateWithoutBookmarkedVideosInput[]
    | UserCreateWithoutBookmarkedVideosInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutBookmarkedVideosInput[]
    | UserUpdateWithWhereUniqueWithoutBookmarkedVideosInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutBookmarkedVideosInput[]
    | UserUpsertWithWhereUniqueWithoutBookmarkedVideosInput;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface TagUpdateDataInput {
  value?: String;
  text?: String;
}

export interface TopicWhereInput {
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  AND?: TopicWhereInput[] | TopicWhereInput;
  OR?: TopicWhereInput[] | TopicWhereInput;
  NOT?: TopicWhereInput[] | TopicWhereInput;
}

export interface UserCreateOneWithoutPasswordResetCodeInput {
  create?: UserCreateWithoutPasswordResetCodeInput;
  connect?: UserWhereUniqueInput;
}

export interface RatingCreateInput {
  votes: Int;
  total: Int;
}

export interface TopicsCreateInput {
  exist?: TopicCreateManyInput;
}

export interface PasswordResetCodeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PasswordResetCodeWhereInput;
  AND?:
    | PasswordResetCodeSubscriptionWhereInput[]
    | PasswordResetCodeSubscriptionWhereInput;
  OR?:
    | PasswordResetCodeSubscriptionWhereInput[]
    | PasswordResetCodeSubscriptionWhereInput;
  NOT?:
    | PasswordResetCodeSubscriptionWhereInput[]
    | PasswordResetCodeSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VideoPreviousValuesNode {
  ytId: String;
  complexity: Complexity;
}

export interface VideoPreviousValues
  extends Promise<VideoPreviousValuesNode>,
    Fragmentable {
  ytId: () => Promise<String>;
  complexity: () => Promise<Complexity>;
}

export interface VideoPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoPreviousValuesNode>>,
    Fragmentable {
  ytId: () => Promise<AsyncIterator<String>>;
  complexity: () => Promise<AsyncIterator<Complexity>>;
}

export interface RatingNode {
  votes: Int;
  total: Int;
}

export interface Rating extends Promise<RatingNode>, Fragmentable {
  votes: () => Promise<Int>;
  total: () => Promise<Int>;
}

export interface RatingSubscription
  extends Promise<AsyncIterator<RatingNode>>,
    Fragmentable {
  votes: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
}

export interface VideoNode {
  ytId: String;
  complexity: Complexity;
}

export interface Video extends Promise<VideoNode>, Fragmentable {
  ytId: () => Promise<String>;
  complexity: () => Promise<Complexity>;
  topics: <T = Promise<Array<TopicNode>>>(
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<Array<TagNode>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  adder: <T = User>() => T;
  bookmarkers: <T = Promise<Array<UserNode>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface VideoSubscription
  extends Promise<AsyncIterator<VideoNode>>,
    Fragmentable {
  ytId: () => Promise<AsyncIterator<String>>;
  complexity: () => Promise<AsyncIterator<Complexity>>;
  topics: <T = Promise<AsyncIterator<Array<TopicSubscription>>>>(
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<Array<TagSubscription>>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  adder: <T = UserSubscription>() => T;
  bookmarkers: <T = Promise<AsyncIterator<Array<UserSubscription>>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RatingConnectionNode {}

export interface RatingConnection
  extends Promise<RatingConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<RatingEdgeNode>>>() => T;
  aggregate: <T = AggregateRating>() => T;
}

export interface RatingConnectionSubscription
  extends Promise<AsyncIterator<RatingConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<RatingEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateRatingSubscription>() => T;
}

export interface UserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayload
  extends Promise<UserSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface TopicNode {
  value: String;
  text: String;
}

export interface Topic extends Promise<TopicNode>, Fragmentable {
  value: () => Promise<String>;
  text: () => Promise<String>;
}

export interface TopicSubscription
  extends Promise<AsyncIterator<TopicNode>>,
    Fragmentable {
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideoNode {
  count: Int;
}

export interface AggregateVideo
  extends Promise<AggregateVideoNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoSubscription
  extends Promise<AsyncIterator<AggregateVideoNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoEdgeNode {
  cursor: String;
}

export interface VideoEdge extends Promise<VideoEdgeNode>, Fragmentable {
  node: <T = Video>() => T;
  cursor: () => Promise<String>;
}

export interface VideoEdgeSubscription
  extends Promise<AsyncIterator<VideoEdgeNode>>,
    Fragmentable {
  node: <T = VideoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserNode {
  count: Int;
}

export interface AggregateUser
  extends Promise<AggregateUserNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUserNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePasswordResetCodeNode {
  count: Int;
}

export interface AggregatePasswordResetCode
  extends Promise<AggregatePasswordResetCodeNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePasswordResetCodeSubscription
  extends Promise<AsyncIterator<AggregatePasswordResetCodeNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnectionNode {}

export interface UserConnection
  extends Promise<UserConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<UserEdgeNode>>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<UserEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PasswordResetCodeEdgeNode {
  cursor: String;
}

export interface PasswordResetCodeEdge
  extends Promise<PasswordResetCodeEdgeNode>,
    Fragmentable {
  node: <T = PasswordResetCode>() => T;
  cursor: () => Promise<String>;
}

export interface PasswordResetCodeEdgeSubscription
  extends Promise<AsyncIterator<PasswordResetCodeEdgeNode>>,
    Fragmentable {
  node: <T = PasswordResetCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TopicsEdgeNode {
  cursor: String;
}

export interface TopicsEdge extends Promise<TopicsEdgeNode>, Fragmentable {
  node: <T = Topics>() => T;
  cursor: () => Promise<String>;
}

export interface TopicsEdgeSubscription
  extends Promise<AsyncIterator<TopicsEdgeNode>>,
    Fragmentable {
  node: <T = TopicsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AccountActivationCodeNode {
  id: ID_Output;
}

export interface AccountActivationCode
  extends Promise<AccountActivationCodeNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
}

export interface AccountActivationCodeSubscription
  extends Promise<AsyncIterator<AccountActivationCodeNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AccountActivationCodeSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AccountActivationCodeSubscriptionPayload
  extends Promise<AccountActivationCodeSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AccountActivationCode>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AccountActivationCodePreviousValues>() => T;
}

export interface AccountActivationCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AccountActivationCodeSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AccountActivationCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AccountActivationCodePreviousValuesSubscription>() => T;
}

export interface TopicsNode {}

export interface Topics extends Promise<TopicsNode>, Fragmentable {
  exist: <T = Promise<Array<TopicNode>>>(
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TopicsSubscription
  extends Promise<AsyncIterator<TopicsNode>>,
    Fragmentable {
  exist: <T = Promise<AsyncIterator<Array<TopicSubscription>>>>(
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AccountActivationCodePreviousValuesNode {
  id: ID_Output;
}

export interface AccountActivationCodePreviousValues
  extends Promise<AccountActivationCodePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface AccountActivationCodePreviousValuesSubscription
  extends Promise<AsyncIterator<AccountActivationCodePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateTopicNode {
  count: Int;
}

export interface AggregateTopic
  extends Promise<AggregateTopicNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopicSubscription
  extends Promise<AsyncIterator<AggregateTopicNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PasswordResetCodeConnectionNode {}

export interface PasswordResetCodeConnection
  extends Promise<PasswordResetCodeConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<PasswordResetCodeEdgeNode>>>() => T;
  aggregate: <T = AggregatePasswordResetCode>() => T;
}

export interface PasswordResetCodeConnectionSubscription
  extends Promise<AsyncIterator<PasswordResetCodeConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<PasswordResetCodeEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregatePasswordResetCodeSubscription>() => T;
}

export interface TopicConnectionNode {}

export interface TopicConnection
  extends Promise<TopicConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<TopicEdgeNode>>>() => T;
  aggregate: <T = AggregateTopic>() => T;
}

export interface TopicConnectionSubscription
  extends Promise<AsyncIterator<TopicConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<TopicEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateTopicSubscription>() => T;
}

export interface PasswordResetCodeSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PasswordResetCodeSubscriptionPayload
  extends Promise<PasswordResetCodeSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PasswordResetCode>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PasswordResetCodePreviousValues>() => T;
}

export interface PasswordResetCodeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PasswordResetCodeSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PasswordResetCodeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PasswordResetCodePreviousValuesSubscription>() => T;
}

export interface TagsEdgeNode {
  cursor: String;
}

export interface TagsEdge extends Promise<TagsEdgeNode>, Fragmentable {
  node: <T = Tags>() => T;
  cursor: () => Promise<String>;
}

export interface TagsEdgeSubscription
  extends Promise<AsyncIterator<TagsEdgeNode>>,
    Fragmentable {
  node: <T = TagsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PasswordResetCodePreviousValuesNode {
  id: ID_Output;
}

export interface PasswordResetCodePreviousValues
  extends Promise<PasswordResetCodePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface PasswordResetCodePreviousValuesSubscription
  extends Promise<AsyncIterator<PasswordResetCodePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface TagsNode {}

export interface Tags extends Promise<TagsNode>, Fragmentable {
  exist: <T = Promise<Array<TagNode>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TagsSubscription
  extends Promise<AsyncIterator<TagsNode>>,
    Fragmentable {
  exist: <T = Promise<AsyncIterator<Array<TagSubscription>>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserPreviousValuesNode {
  id: ID_Output;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
}

export interface UserPreviousValues
  extends Promise<UserPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isActivated: () => Promise<Boolean>;
  login: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isActivated: () => Promise<AsyncIterator<Boolean>>;
  login: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTagNode {
  count: Int;
}

export interface AggregateTag extends Promise<AggregateTagNode>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTagNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RatingSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RatingSubscriptionPayload
  extends Promise<RatingSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Rating>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RatingPreviousValues>() => T;
}

export interface RatingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RatingSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RatingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RatingPreviousValuesSubscription>() => T;
}

export interface TagConnectionNode {}

export interface TagConnection
  extends Promise<TagConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<TagEdgeNode>>>() => T;
  aggregate: <T = AggregateTag>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<TagEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface RatingPreviousValuesNode {
  votes: Int;
  total: Int;
}

export interface RatingPreviousValues
  extends Promise<RatingPreviousValuesNode>,
    Fragmentable {
  votes: () => Promise<Int>;
  total: () => Promise<Int>;
}

export interface RatingPreviousValuesSubscription
  extends Promise<AsyncIterator<RatingPreviousValuesNode>>,
    Fragmentable {
  votes: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
}

export interface RatingEdgeNode {
  cursor: String;
}

export interface RatingEdge extends Promise<RatingEdgeNode>, Fragmentable {
  node: <T = Rating>() => T;
  cursor: () => Promise<String>;
}

export interface RatingEdgeSubscription
  extends Promise<AsyncIterator<RatingEdgeNode>>,
    Fragmentable {
  node: <T = RatingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAccountActivationCodeNode {
  count: Int;
}

export interface AggregateAccountActivationCode
  extends Promise<AggregateAccountActivationCodeNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAccountActivationCodeSubscription
  extends Promise<AsyncIterator<AggregateAccountActivationCodeNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdgeNode {
  cursor: String;
}

export interface UserEdge extends Promise<UserEdgeNode>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdgeNode>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TagSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TagSubscriptionPayload
  extends Promise<TagSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Tag>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValues>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TopicsConnectionNode {}

export interface TopicsConnection
  extends Promise<TopicsConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<TopicsEdgeNode>>>() => T;
  aggregate: <T = AggregateTopics>() => T;
}

export interface TopicsConnectionSubscription
  extends Promise<AsyncIterator<TopicsConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<TopicsEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateTopicsSubscription>() => T;
}

export interface TagPreviousValuesNode {
  value: String;
  text: String;
}

export interface TagPreviousValues
  extends Promise<TagPreviousValuesNode>,
    Fragmentable {
  value: () => Promise<String>;
  text: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValuesNode>>,
    Fragmentable {
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface UserNode {
  id: ID_Output;
  isActivated?: Boolean;
  login: String;
  email: String;
  password: String;
  name: String;
}

export interface User extends Promise<UserNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  activationCode: <T = AccountActivationCode>() => T;
  passwordResetCode: <T = PasswordResetCode>() => T;
  isActivated: () => Promise<Boolean>;
  login: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  myVideos: <T = Promise<Array<VideoNode>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bookmarkedVideos: <T = Promise<Array<VideoNode>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<UserNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  activationCode: <T = AccountActivationCodeSubscription>() => T;
  passwordResetCode: <T = PasswordResetCodeSubscription>() => T;
  isActivated: () => Promise<AsyncIterator<Boolean>>;
  login: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  myVideos: <T = Promise<AsyncIterator<Array<VideoSubscription>>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  bookmarkedVideos: <T = Promise<AsyncIterator<Array<VideoSubscription>>>>(
    args?: {
      where?: VideoWhereInput;
      orderBy?: VideoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AccountActivationCodeEdgeNode {
  cursor: String;
}

export interface AccountActivationCodeEdge
  extends Promise<AccountActivationCodeEdgeNode>,
    Fragmentable {
  node: <T = AccountActivationCode>() => T;
  cursor: () => Promise<String>;
}

export interface AccountActivationCodeEdgeSubscription
  extends Promise<AsyncIterator<AccountActivationCodeEdgeNode>>,
    Fragmentable {
  node: <T = AccountActivationCodeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTagsNode {
  count: Int;
}

export interface AggregateTags
  extends Promise<AggregateTagsNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagsSubscription
  extends Promise<AsyncIterator<AggregateTagsNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagsSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TagsSubscriptionPayload
  extends Promise<TagsSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Tags>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface TagsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagsSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface PasswordResetCodeNode {
  id: ID_Output;
}

export interface PasswordResetCode
  extends Promise<PasswordResetCodeNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = User>() => T;
}

export interface PasswordResetCodeSubscription
  extends Promise<AsyncIterator<PasswordResetCodeNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRatingNode {
  count: Int;
}

export interface AggregateRating
  extends Promise<AggregateRatingNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRatingSubscription
  extends Promise<AsyncIterator<AggregateRatingNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TopicSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TopicSubscriptionPayload
  extends Promise<TopicSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Topic>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TopicPreviousValues>() => T;
}

export interface TopicSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopicSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopicSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TopicPreviousValuesSubscription>() => T;
}

export interface AggregateTopicsNode {
  count: Int;
}

export interface AggregateTopics
  extends Promise<AggregateTopicsNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopicsSubscription
  extends Promise<AsyncIterator<AggregateTopicsNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TopicEdgeNode {
  cursor: String;
}

export interface TopicEdge extends Promise<TopicEdgeNode>, Fragmentable {
  node: <T = Topic>() => T;
  cursor: () => Promise<String>;
}

export interface TopicEdgeSubscription
  extends Promise<AsyncIterator<TopicEdgeNode>>,
    Fragmentable {
  node: <T = TopicSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TagNode {
  value: String;
  text: String;
}

export interface Tag extends Promise<TagNode>, Fragmentable {
  value: () => Promise<String>;
  text: () => Promise<String>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<TagNode>>,
    Fragmentable {
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface TopicsSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TopicsSubscriptionPayload
  extends Promise<TopicsSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Topics>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface TopicsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopicsSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopicsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface AccountActivationCodeConnectionNode {}

export interface AccountActivationCodeConnection
  extends Promise<AccountActivationCodeConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<AccountActivationCodeEdgeNode>>>() => T;
  aggregate: <T = AggregateAccountActivationCode>() => T;
}

export interface AccountActivationCodeConnectionSubscription
  extends Promise<AsyncIterator<AccountActivationCodeConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<Array<AccountActivationCodeEdgeSubscription>>>
  >() => T;
  aggregate: <T = AggregateAccountActivationCodeSubscription>() => T;
}

export interface TopicPreviousValuesNode {
  value: String;
  text: String;
}

export interface TopicPreviousValues
  extends Promise<TopicPreviousValuesNode>,
    Fragmentable {
  value: () => Promise<String>;
  text: () => Promise<String>;
}

export interface TopicPreviousValuesSubscription
  extends Promise<AsyncIterator<TopicPreviousValuesNode>>,
    Fragmentable {
  value: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface TagsConnectionNode {}

export interface TagsConnection
  extends Promise<TagsConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<TagsEdgeNode>>>() => T;
  aggregate: <T = AggregateTags>() => T;
}

export interface TagsConnectionSubscription
  extends Promise<AsyncIterator<TagsConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<TagsEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateTagsSubscription>() => T;
}

export interface VideoSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface VideoSubscriptionPayload
  extends Promise<VideoSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Video>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoPreviousValues>() => T;
}

export interface VideoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoPreviousValuesSubscription>() => T;
}

export interface VideoConnectionNode {}

export interface VideoConnection
  extends Promise<VideoConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<VideoEdgeNode>>>() => T;
  aggregate: <T = AggregateVideo>() => T;
}

export interface VideoConnectionSubscription
  extends Promise<AsyncIterator<VideoConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<VideoEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateVideoSubscription>() => T;
}

export interface TagEdgeNode {
  cursor: String;
}

export interface TagEdge extends Promise<TagEdgeNode>, Fragmentable {
  node: <T = Tag>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdgeNode>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`
});
export const prisma = new Prisma();
